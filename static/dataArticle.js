var dataArticle = {
    "list": [{
        "id": 0,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"ajax\">Ajax</h1>\n<h2 id=\"-\"><strong><em>作用: 从服务端获取数据</em></strong></h2>\n<ol>\n<li>浏览网页流程  (打开页面.请求服务端内容)<br>客户端(client)向服务器(server)请求数据\n服务器返回数据给客户端</li>\n<li>协议:<ul>\n<li>file:// (本地协议, 访问本地的数据)</li>\n<li>https:// (超文本传输协议,访问到服务器的数据)</li>\n</ul>\n</li>\n<li>域名:\n baidu.com</li>\n<li>如果......</li>\n</ol>\n<a href=/?0 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"ajax\">Ajax</h1>\n<h2 id=\"-\"><strong><em>作用: 从服务端获取数据</em></strong></h2>\n<ol>\n<li>浏览网页流程  (打开页面.请求服务端内容)<br>客户端(client)向服务器(server)请求数据\n服务器返回数据给客户端</li>\n<li>协议:<ul>\n<li>file:// (本地协议, 访问本地的数据)</li>\n<li>https:// (超文本传输协议,访问到服务器的数据)</li>\n</ul>\n</li>\n<li>域名:\n baidu.com</li>\n<li>如果想让别人访问自己的页面,就要把自己的资源上传到别人可以访问到的服务器上</li>\n<li>wamp(win平台服务器集成软件)</li>\n<li>域名最终会解析成ip,如www.baidu.com会被解析成ip: 192.202.x.x,所以直接在地址栏输入ip也可以访问</li>\n<li>自带计算机域名是localhost,ip为127.0.0.1</li>\n<li><p>jQuery里的格式:</p>\n<pre><code class=\"lang-javascript\"> $.ajax({\n     url: &#39;xxx.php&#39;,\n     data: {\n         key1: value1,\n         key2: value2,\n         ....            \n     }\n     success: function(data){\n         data = JSON.parse(data);\n         ...(渲染语句)\n     },\n     error: function(XMLHttpRequest,a) {\n         console.log(XMLHttpRequest)----XMLHttpRequest是一个ajax对象,其中有属性status(表征获取成功与否的http状态码,如404)和描述statusText    \n         console.log(a)---(错误信息,如果是error就说明出错了)    \n     }\n })\n</code></pre>\n</li>\n<li>一些状态码:<ul>\n<li>200请求成功</li>\n<li>304成功,(特殊的,走的缓存)</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>关于apache配置:</strong></p>\n<ol>\n<li>有冲突,改端口</li>\n<li>把有个地方的配置改成all</li>\n<li>关于修改根目录,详见同级文件夹里的apache说明txt文件</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"ajax-asynchronous-javascript-and-xml-\">AJAX(Asynchronous Javascript And Xml)工作原理</h2>\n<p>校验注册信息,如用户名 时,先用正则表达式判断语法,然后发给后台,校验是否已存在</p>\n<p><form action=\"xx(提交地址).xx\" method=\"(提交方法)get/post\">\n两种方法中只有<strong>get</strong>方式才会把所填的信息<strong>显示在地址栏</strong>上,post不会显示在地址栏</p>\n<p>search/hash\nsearch是?开头的键值对: ?key=value &amp; key=value</p>\n<p>ajax对象: XMLHttpRequest构造函数xhr</p>\n<hr>\n<h4 id=\"-get-post-\"><em>get和post</em>区别:</h4>\n<p>一个是通过地址栏url传递数据<br>另一个是通过把数据用send方法传给后台,数据不会暴露在地址栏</p>\n<hr>\n<p>原生方法:</p>\n<ol>\n<li><p>构造对象<br>var xhr = new XMLHttpRequest;</p>\n</li>\n<li><p>链接地址,准备数据<br>xhr.open(&#39;Get&#39;,&#39;<a href=\"http://xxx.php?user=\">http://xxx.php?user=</a>&#39; +username,false) \n xhr.open(&#39;Post&#39;,&#39;<a href=\"http://xxx.php?user=\">http://xxx.php?user=</a>&#39; ,true)<br> <em>上边第三个参数是是否异步,false是同步,true是异步</em></p>\n</li>\n<li><p>服务器响应请求,所有请求响应完毕后会触发一个事件  (该事件要提前绑定好,有可能响应速度很快)</p>\n<pre><code class=\"lang-javascript\"> xhr.onload = function() {\n     //校验完成(无论成功还是失败)后返回的数据(如&#39;用户名已经存在&#39;):\n     var data = xhr.responseText;\n     //然后使用该属性,显示在页面中就好,就做到了局部刷新\n\n     //获取到状态码,\n     xhr.status\n     //....此时,校验已完成....\n }\n</code></pre>\n</li>\n<li><p>发送给服务器<br><strong>GET方法下</strong>:<br><code>xhr.send()</code><br><strong>POST方法下</strong>:<br>post可以提交多种格式的数据,设置一个请求头,告诉后端发送的是什么样的格式的数据   </p>\n<pre><code>         `xhr.setRequestHeader(&quot;Content-Type&quot;,&#39;application/x-www-form-urlencoded&#39;) `  \n</code></pre><p>最后,<br><code>xhr.send(&quot;user=&quot; + this.value)</code></p>\n</li>\n</ol>\n<hr>\n<h4 id=\"-\">流程如下</h4>\n<p>每个流程对应一个<strong>编号</strong>,一个属性的值(xhr.readyState)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:left\">步骤</th>\n<th style=\"text-align:center\">编号(xhr.readyState)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">构造对象</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">链接地址,准备数据</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:left\">发送给服务器</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:left\">服务器响应,返回数据</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:left\">全部响应完毕,触发onload事件</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<blockquote>\n<p><strong>异步&amp;同步</strong><br>js代码是<em>自上而下</em>执行的(也即默认同步执行)<br>异步就是说前面代码很耗时时,下面代码不会等到上面代码执行完后就先执行<br>同步就是严格自上而下执行</p>\n</blockquote>\n<h4 id=\"-ajax-jquery-ajax-\">自己封装的ajax函数(仿jquery中的<code>$.ajax()</code>)</h4>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh-cn&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n          &lt;title&gt;&lt;/title&gt;\n        &lt;script src=&quot;./jq3.js&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;p&gt;用户名：&lt;input id=&quot;userName&quot; type=&quot;&quot; name=&quot;user&quot;&gt;&lt;span id=&quot;tip&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n        &lt;p&gt;手机号码：&lt;input id=&quot;tellNumber&quot; type=&quot;&quot; name=&quot;user&quot;&gt;&lt;span id=&quot;tip1&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n        &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;&quot;&gt;&lt;/p&gt;\n        &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;提交&quot; /&gt;\n\n        &lt;script src=&quot;./jq3.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            /*\n                封装的是get请求和post请求这两种情况\n\n                不一样的：\n                    请求方式不一样 传参  默认 get\n                    请求地址不一样 传参  *\n                    可设置同步异步  传参  默认 true\n                    请求的数据      传参  默认为&quot;&quot;\n                    成功的回调函数  传参  \n                        执行成功回调函数的时候得到后端传过来的数据\n                    失败的回调函数  传参  \n                        状态码\n\n            */\n            function ajax(options){\n                var defaults = {\n                    url:&quot;&quot;,        //请求地址\n                    method:&quot;get&quot;,  //请求方式\n                    data:&#39;&#39;,       //请求的数据\n                    isAsyn:true,   //是否为异步\n                    success:function(){}, //成功执行的回掉函数\n                    error:function(){}    //失败执行的回掉函数\n                };\n\n                $.extend(defaults,options);\n                //如果地址没有填写，抛出错误\n                if( defaults.url.trim() === &quot;&quot; ){\n                    throw new Error(&quot;请求地址不能为空&quot;);\n                }\n\n                var xhr = new XMLHttpRequest();\n\n                if( defaults.method === &quot;get&quot; ){\n                    defaults.url += &quot;?&quot;+defaults.data;\n                }\n\n                xhr.open(defaults.method,defaults.url,defaults.isAsyn);\n\n\n                xhr.onload = function (){\n                    if( xhr.status === 200 ){  //成功\n                        defaults.success(xhr.responseText)\n                    } else { //失败\n                        defaults.error(xhr.status,xhr.statusText);\n                    }\n                };\n\n\n                if( defaults.method === &quot;get&quot; ){\n                    xhr.send();\n                }else if(defaults.method === &quot;post&quot;){\n                    xhr.setRequestHeader(&quot;Content-Type&quot;,&#39;application/x-www-form-urlencoded&#39;);\n                    xhr.send(defaults.data);\n                }\n            }\n\n            userName.onblur = function (){\n                ajax({\n                    url:&#39;http://localhost/2017-01-10/php/post.php&#39;,\n                    data:&quot;user=&quot;+this.value,\n                    method:&quot;post&quot;,\n                    success:function (data){\n                        console.log( data );\n                    }\n                });    \n            };\n\n            tellNumber.onblur = function (){\n                ajax({\n                    url:&quot;http://localhost/2017-01-10/php/get.php&quot;,\n                    data:&quot;user=&quot;+this.value,\n                    success(data){\n                        console.log(data);\n                    }\n                });        \n            };\n\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<hr>\n<p>#兼容性 \nget方法:IE下,中文要手动进行url编码,ie才会识别<br>post方法: 由于设置了请求头,就不需要url编码了</p>\n<blockquote>\n<p> url编码<br>encodeURI(&quot;哈&quot;)-----编码<br>decodeURI(&quot;%E5%F2%DD&quot;)-----解码</p>\n</blockquote>\n<p>#上传&amp;&amp;下载</p>\n<p>下载会调用第三方下载工具,就不说了<br>主要讲<strong>上传</strong></p>\n<p><strong>上传本地文件(用input:files标签)</strong>  </p>\n<pre><code class=\"lang-html\">&lt;input type=&quot;file&quot; name=&quot;(后端约定好的)&quot; id=&quot;fileInput&quot;&gt;\n&lt;input type=&quot;button&quot; value=&quot;上传&quot; id=&quot;btn&quot;&gt;\n&lt;script&gt;\n    //要用post方法  \n    btn.onclick = function() {\n        var xhr = new XMLHttpRequest;\n        xhr.open(&quot;post&quot;, url, true);\n        //不能用value,value只会拿到该文件的本地路径,要用files,对应的是一个数组\n        console.log(fileInput.files[0]);\n        //用files拿到要上传的文件以后,要把它转换成二进制文件↘\n        var fd = new FormData();\n\n        //append()是fd对象的方法,第一个参数是key值(前后端约定好的) \n        fd.append(&quot;files&quot;, fileInput.files[0]);\n\n\n        //就不用这么写了---xhr.send(&quot;file=&quot;+fileInput.files[0]);\n    }\n&lt;/script&gt;\n</code></pre>\n<hr>\n<h1 id=\"-\">跨域</h1>\n<ol>\n<li><p>同源策略(域名,协议,端口()http:80;https:443;ftp:21 22 23相同)<br> 百度只能获取到自己的数据,但不能访问到taobao的数据</p>\n<blockquote>\n<pre><code>www.baidu.com 主域名(一级域名)  \nnews.baidu.com 二级域名  \n123.ss.baidu.com 三级域名\n</code></pre></blockquote>\n<p> 当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，<br>即检查是否同源，只有和百度同源的脚本才会被执行</p>\n</li>\n<li><p>电脑上每个软件都有一个端口</p>\n</li>\n</ol>\n<h1 id=\"-\">跨域方式:</h1>\n<ol>\n<li>Ajax方法<ol>\n<li>后端加一个请求头部,允许指定ip或者*(任何ip)访问数据</li>\n<li>请求本地服务器的后台程序,在这个后台程序里请求别的服务器的后台数据(后台之间请求数据不存在跨域问题)</li>\n<li><del>flash方法</del></li>\n</ol>\n</li>\n<li><p>jsonp(json+padding用json格式来填充数据)方式<br> 后端设置jsonp的请求格式 ,只能用get方式<br> \\<img src可以用base64(是一串字符串,图片的一种格式)来写,浏览器不关心里边数据是什么样子,他关心数据能否转成一张图片>,\\<script>,\\<link>三类标签是可以跨域的<br> jsonp是用script标签来跨域的,举例:</p>\n<ol>\n<li><p>(动态引入js)点击document生成一个script标签,这个标签的src属性是外部的php,js之类的文件的地址,这个时候在他们的文件内部要有一个函数调用,如fn();与此同时在函数外部,要定义这个函数,以便执行刚才的调用</p>\n<pre><code class=\"lang-javascript\"> function abc(data) {\n     console.log(data);\n }\n document.onclick = function() {\n     var script = document.createElement(&quot;script&quot;);\n     script.src = &quot;http://192.168.2.138/2017-11-12/kuayu/jsonp.php?cb=abc&quot;\n     document.body.appendChild(script);\n }\n</code></pre>\n<p><code>cb =&gt; callback</code></p>\n</li>\n<li>案例: 搜索建议</li>\n</ol>\n</li>\n</ol>\n"
    }, {
        "id": 1,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"canvas-\">canvas学习笔记</h1>\n<ol>\n<li><code>&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</code><ol>\n<li>没有设置宽高,默认300px * 150px</li>\n<li>css设置要和标签设置保持一致,要不然会出现扭曲</li>\n<li>WebGL (Web Graphics Library) 是一个用以渲染交互式3D和2D图形的无需插件且兼容下一代浏览......</li>\n</ol>\n</li>\n</ol>\n<a href=/?1 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"canvas-\">canvas学习笔记</h1>\n<ol>\n<li><code>&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</code><ol>\n<li>没有设置宽高,默认300px * 150px</li>\n<li>css设置要和标签设置保持一致,要不然会出现扭曲</li>\n<li>WebGL (Web Graphics Library) 是一个用以渲染交互式3D和2D图形的无需插件且兼容下一代浏览器的 JavaScript API。WebGL 引用的JavaScript API遵守OpenGL ES2.0规范，通过HTML5中 \\<canvas> 元素实现功能。</li>\n</ol>\n</li>\n<li><p><code>var ctx = canvas.getContext(&#39;2d&#39;);</code>获取渲染上下文对象</p>\n<ol>\n<li>分为2d渲染上下文以及3d上下文(着重2d)</li>\n</ol>\n</li>\n<li><p>绘制形状: </p>\n<ol>\n<li>矩形: <code>cxt.fillRect(0,0,150,75)</code><ul>\n<li>从<strong>(0,0)点</strong>开始, 绘制一个<strong>150x75</strong>的矩形</li>\n</ul>\n</li>\n<li>线条: 步骤<ol>\n<li><code>cxt.moveTo(0,0);</code>//绘制线条起点</li>\n<li><code>cxt.lineTo(10,10);</code></li>\n<li><code>cxt.lineTo(100,10);</code></li>\n<li><code>cxt.stroke();</code></li>\n</ol>\n</li>\n<li><p>圆形</p>\n<ol>\n<li><code>cxt.beginPath();</code></li>\n<li><p><code>cxt.arc(x,y(圆心坐标),半径,起点弧度,终点弧度,是否顺时针(默认false))</code></p>\n<blockquote>\n<p>说明:  </p>\n<ol>\n<li>角度都是以右端为起点,顺时针计算  </li>\n<li>坐标是以canvas基准点为准,可以通过ctx.translate(x, y)移动此基点</li>\n</ol>\n</blockquote>\n</li>\n<li><p><code>cxt.closePath();</code></p>\n</li>\n<li><code>cxt.fillStyle = &quot;#fff000&quot;</code></li>\n<li><code>ctx.fill();</code>//圆形里是必须的</li>\n</ol>\n</li>\n<li>渐变<ol>\n<li>var grd = cxt.createLinearGradient(0,0,175,50);</li>\n<li>grd.addColorStop(0,&quot;#f00&quot;);grd.addColorStop(1,&quot;#00f&quot;);</li>\n<li>cxt.fillStyle = grd;</li>\n<li>cxt.fillRect(0,0,175,50)</li>\n</ol>\n</li>\n<li>放一幅画<ol>\n<li>var img = new Image();</li>\n<li>img.src = &quot;flower.png&quot;</li>\n<li>cxt.drawImage(img,0,0)</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>填充颜色: \n <code>cxt.fillStyle = &quot;#fff000&quot;</code></p>\n</li>\n<li>描边:\n cxt.strokeStyle = &quot;red&quot;;<br> <strong>ctx.beginPath();</strong><br> ctx.moveTo(100, 100);<br> ctx.lineTo(300, 100);<br> ctx.lineTo(300, 200);<br> ctx.lineTo(100, 200);<br> <strong>ctx.closePath();</strong><br> //描边<br> ctx.stroke();   </li>\n</ol>\n<hr>\n<p>另外: \nHTML5支持内联SVG,<br>代码如下:</p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt;\n  &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot;\n  style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt;\n&lt;/svg&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n"
    }, {
        "id": 2,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"cookie-localstorage\">Cookie&amp;&amp;LocalStorage</h1>\n<ol>\n<li>不同域名下的cookie不能访问</li>\n<li>比如登录信息一般会用cookie存起来,访问同一个域名下的不同页面都可以读取到他</li>\n</ol>\n<h2 id=\"-cookie\">操作cookie</h2>\n<p>document.cookie = &quot;key=value&quot;\ndocument.cookie = &quot;key2=value2&quot;\ndocument.cookie = &quot;key3=v......</p>\n<a href=/?2 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"cookie-localstorage\">Cookie&amp;&amp;LocalStorage</h1>\n<ol>\n<li>不同域名下的cookie不能访问</li>\n<li>比如登录信息一般会用cookie存起来,访问同一个域名下的不同页面都可以读取到他</li>\n</ol>\n<h2 id=\"-cookie\">操作cookie</h2>\n<p>document.cookie = &quot;key=value&quot;\ndocument.cookie = &quot;key2=value2&quot;\ndocument.cookie = &quot;key3=value3&quot;<br>-----设置cookie,这样设置,审查元素的时间特性会是:session(会话阶段),浏览器关闭后,cookie会自动清空  </p>\n<p>这个时间(想要让cookie在未来某个时刻清空)也可以设置(例如一些网站会有记录登录状态7天的选项)</p>\n<pre><code class=\"lang-javascript\">var d = new Date();\nd.setDate(d.getData()+7);//设置7天后的时间\n\n/*d.toUTCString()把一个日期对象转换成字符串,采用世界时间UTC格式*/\n\ndocument.cookie = &quot;key3=value3; expires(到期)=&quot;+d;\n</code></pre>\n<hr>\n<p>document.cookie; =&gt;&quot;key=value; key2=value2; key3=value3&quot;<br>-----查看cookie</p>\n<hr>\n<p>-----删除</p>\n<h2 id=\"-localstorage-5m-\">操作localStorage(大部分浏览器支持,最大5M)</h2>\n<pre><code class=\"lang-javascript\">//具体应用\nlocalStorage.setItem(&quot;message&quot;,JSON.stringify(message));  \nvar data = localStorage.getItem(&#39;message&#39;);\nif(data) {\n    data = JSON.parse(data);\n    ....使用...,渲染页面之类的事情\n} else {\n    //没有从本地存储获取到\n    ....\n}\n</code></pre>\n<p>localStorage.setItem(key,value)---设置\nlocalStorage.getItem(key,value)---获取\nlocalStorage.removeItem(key)---清除指定键值对应的本地存储\nlocalStorage.clear()---清除全部本地存储\n---storage事件:<br>注意的点:<br><strong>在窗口a修改localstorage,只会在b窗口触发storage事件,不会触发自身的storage事件</strong><br>对localStorage进行增删改会触发(多用于不同窗口打开同一页面)</p>\n<pre><code class=\"lang-javascript\">window.addEventListener(&#39;storage&#39;, function() {})\n</code></pre>\n"
    }, {
        "id": 3,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"date-\">Date对象</h1>\n<p> <em>通过new Date()可以生成一个对象,该对象包含当前系统时间的所有信息</em></p>\n<ol>\n<li>var t1 = new Date(2016,9,27,10,5,12);//年，月，日，时，分，秒(注意，月份是从0开始的)</li>\n<li>var t2 = new Date(&#39;Oct 27,2016 10:10:12&#39;)//传入一个字符串 &quot;月份  日期,年份 时:分:秒&quot;\n3......</li>\n</ol>\n<a href=/?3 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"date-\">Date对象</h1>\n<p> <em>通过new Date()可以生成一个对象,该对象包含当前系统时间的所有信息</em></p>\n<ol>\n<li>var t1 = new Date(2016,9,27,10,5,12);//年，月，日，时，分，秒(注意，月份是从0开始的)</li>\n<li>var t2 = new Date(&#39;Oct 27,2016 10:10:12&#39;)//传入一个字符串 &quot;月份  日期,年份 时:分:秒&quot;</li>\n<li>var t3 = new Date(new Date().getTime())//传入一个时间戳</li>\n</ol>\n<p><em>这些方法都会返回一个数字</em></p>\n<ul>\n<li>getFullYear()          获取年</li>\n<li>getMonth()             获取月  (月份从0开始计算)</li>\n<li><p>getDate()             获取日 </p>\n<pre><code class=\"lang-javascript\">t.setDate(0);//设置日期为0\nt.setDate(32);//不会报错，会自动向下一个月进位\n</code></pre>\n</li>\n<li>getDay()             获取星期 （星期从周日开始，从0开始计算）</li>\n<li>getHours()           获取小时</li>\n<li>getMinutes()          获取分钟</li>\n<li>getSeconds()          获取秒钟</li>\n<li>getMilliseconds() 获取毫秒</li>\n<li>getTime()              获取1970-01-01 00:00:00到目前日期对象的时间差（单位:毫秒）</li>\n</ul>\n<p>设置日期对象的方法setXxx()返回的是时间戳</p>\n"
    }, {
        "id": 4,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"dom-\">DOM操作</h1>\n<ol>\n<li>parentNode.appendChild(childNode)添加子节点</li>\n<li>parentNode.insertBefore(childNode1, childNode2),把1插到2之前<ul>\n<li>第二个参数没有,会报错</li>\n<li>第二个参数是null,相当于appendChild</li>\n</ul>\n</li>\n<li>parentNode.removeChild(childNode)\n4.......</li>\n</ol>\n<a href=/?4 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"dom-\">DOM操作</h1>\n<ol>\n<li>parentNode.appendChild(childNode)添加子节点</li>\n<li>parentNode.insertBefore(childNode1, childNode2),把1插到2之前<ul>\n<li>第二个参数没有,会报错</li>\n<li>第二个参数是null,相当于appendChild</li>\n</ul>\n</li>\n<li>parentNode.removeChild(childNode)</li>\n<li>parentNode.replaceChild(node,childNode)</li>\n<li>node.cloneNode(boolean)</li>\n</ol>\n"
    }, {
        "id": 5,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"es6-2015-\">ES6(2015)</h1>\n<hr>\n<h2 id=\"1-\">1. <strong>严格模式</strong></h2>\n<ul>\n<li>ES5的严格模式 <em>&#39;strict mode&#39;</em></li>\n<li><p>进入方法    </p>\n<p>  ```javascript\n  <script></p>\n<pre><code>  &#39;use strict&#39;\n  //整个script标签都会使用严格模式\n  a = 10;\n  //会报错: a is not defined\n</code></pre><p>  </script>\n  ```......</p>\n</li>\n</ul>\n<a href=/?5 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"es6-2015-\">ES6(2015)</h1>\n<hr>\n<h2 id=\"1-\">1. <strong>严格模式</strong></h2>\n<ul>\n<li>ES5的严格模式 <em>&#39;strict mode&#39;</em></li>\n<li><p>进入方法    </p>\n<pre><code class=\"lang-javascript\">  &lt;script&gt;\n      &#39;use strict&#39;\n      //整个script标签都会使用严格模式\n      a = 10;\n      //会报错: a is not defined\n  &lt;/script&gt;\n</code></pre>\n<p>  也可以:</p>\n<pre><code class=\"lang-javascript\">  (function() {\n      &#39;use strict&#39;\n      //只有函数作用域中使用严格模式\n  })()\n</code></pre>\n</li>\n<li><p>一些规则</p>\n<ol>\n<li>首先,变量不声明就赋值,会报错</li>\n<li>直接调用函数,this指向<code>undefined</code>而不是<code>window</code></li>\n<li><p>delete 全局变量会报错</p>\n<blockquote>\n<pre><code>关于删除运算符delete\n    `var a = 1; delete a;//delete不能删除全局变量`\n    `var obj = {a:10}; delete obj.a;//可以删除对象上的属性`\n</code></pre></blockquote>\n</li>\n<li>函数形参不能重名function func(a, a, b)</li>\n<li>不能用arguments命名变量</li>\n<li>函数体中修改形参的值不会改变arguments的值(也即不会跟踪他的变化)</li>\n<li><p>关于函数声明:</p>\n<blockquote>\n<p>js里</p>\n<pre><code> 函数在for或if语句里声明不会预解析提前,而变量一直可以\n</code></pre></blockquote>\n<p>代码示例  </p>\n<pre><code class=\"lang-javascript\">     //&#39;use strict&#39;//正常模式会正常执行,打印 1\n     &#39;use strict&#39;//会报错: Uncaught ReferenceError: a is not defined\n\n     if(true) {\n         function a(){\n             console.log(1);    \n         }\n     }\n     a();\n</code></pre>\n</li>\n<li><p>关于call\n 正常模式下: call()/call(undefined)/call(null)指向window\n 严格模式下: call()是指向undefined</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-es6-\">2. <strong>进入主题: ES6</strong></h2>\n<ul>\n<li>函数中一旦使用了es6语法,默认已经进入严格模式,再使用<code>&#39;use strict&#39;</code>开启严格模式,就会报错</li>\n<li><p>声明变量方式: var / let / const</p>\n<ul>\n<li>var声明<ul>\n<li>的变量作用域由<strong>函数作用域</strong>确定,</li>\n<li>声明会提前,</li>\n<li>声明的全局变量<strong>会</strong>挂载在window上(不利于垃圾回收)</li>\n<li>可以重复声明</li>\n</ul>\n</li>\n<li><p>let声明</p>\n<ul>\n<li>的变量作用域由<strong>当前块级作用域</strong>确定,</li>\n<li>声明不会提前,</li>\n<li>声明的全局变量<strong>不会</strong>挂载在window上,</li>\n<li>不能重复声明,特殊的:  <code>🚫:var a = 1; let a = 1;</code></li>\n<li><p>暂存死区</p>\n<ul>\n<li>定义: 从块的开始到声明这段的部分</li>\n<li><p>运用:</p>\n<pre><code class=\"lang-javascript\">  for(let i = 0; i&lt;5; i++) {\n      ele.onclick = function(){\n          alert(i);\n      }    \n  }\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>const(常量)声明</p>\n<ul>\n<li>定义: 定义后不能重新赋值</li>\n<li><p>特性跟let几乎一样(除了不能重新赋值)</p>\n<ul>\n<li>不能重复声明</li>\n<li>声明不会提前</li>\n</ul>\n</li>\n<li><p>命名建议采用<strong>全大写</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解构赋值:</p>\n<ul>\n<li><p>代码示例</p>\n<pre><code class=\"lang-javascript\">  var arr = [1,2,3,4,5]\n  let [,a,b,c] = arr;\n  console.log(a,b,c)//2,3,4\n\n  let [a,b,c,d,e,f=100]//f不传值的默认值是100\n</code></pre>\n<p>  函数里的用法:</p>\n<pre><code class=\"lang-javascript\">  function ab([a,b,c=100]) {\n      console.log(a,b,c)\n  }\n  ab([1, 2]);\n</code></pre>\n<p>  对象里的用法:  </p>\n<pre><code class=\"lang-javascript\">  obj={aa:1,b:2}   \n\n  let {aa,b}=obj   //aa,b=&gt; 1,2  \n  let {aa:a(修改名),b}=obj   //a,b=&gt; 1,2  \n  //但是aa=&gt;not defined\n</code></pre>\n</li>\n</ul>\n</li>\n<li>模块化:<blockquote>\n<p> Number部分:  </p>\n<pre><code>Number.isNaN();  \nNumber.parseInt();  \nNumber.parseFloat();  \nNumber.isFinite();  \nNumber.inTeger();  \n</code></pre><p>Math部分:<br> Math.trunc();直接去掉小数点后的内容<br> Math.sign();会返回: 1 -1 0 -0 NaN 五种值</p>\n<p>数组部分:<br>Array.from();<br>Array.of()将一组参数转成数组<br>arr.keys() 返回数组的遍历器对象  [<em>for(let key of arr.keys())可以遍历数组的key值</em>]<br>arr.entries()返回数组的遍历器对象[可以用for of遍历每组键值对]\narr.find(回调函数,this的指向)<br>arr.findIndex()<br>arr.fill(arg1,arg2...)拿这些参数去填充 \narr.forEach(function(item){})</p>\n<p>Object部分:<br>Object.keys(obj)//得到对象的key值组成的数组 \nObject.values(obj)//得到对象的value值组成的数组 \nObject.entries(obj)//得到对象的key值组成的数组<br>Object.is(0,-0)/Object.is(NaN,NaN)//用来比较两个值是否相同 =&gt; 输出: false/true//<strong>但是*</strong>[[0===-0/NaN === NaN =&gt; true/false]]<em><br>Object.assign(target[,souce1,souce2...])把这些source对象扩展到target对象上 //与jquery中extend方法的区别: extend可以选择深度克隆,但assign方法只能浅克隆<br>Object.getPrototypeOf(obj)//获取对象的原型对象\nObject.setPrototypeOf(obj)//设置<em>*非内置数据类型</em></em>对象的原型对象<br>Object.defineProperty(obj, prop, descriptor)定义属性</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>for循环遍历数组或对象  </p>\n<ul>\n<li><p>for(let <em>value</em> <strong>of</strong> arr) {}<br>//for of不能遍历<strong>没有**</strong>遍历器函数(iterator)**的对象 (一般对象 键值对是无序的,所以没有遍历器,就不能被for of 遍历)   </p>\n<blockquote>\n<pre><code>关于遍历器:  \n任何数据类型只要有这个方法,就可以被遍历\n\n```javascript\nArray.prototype[Symbol.iterator]= function(){\n里边大概是: \n    var index = 0;\n    return {\n        next: function(){\n                return index &lt; arr.length? {\n                    value: this[index++],\n                    done: false\n                } : {\n                    value: undefined,\n                    done: true\n                }\n            }\n\n    }\n}\n\n//给Object手动添加遍历器\nObject.prototype[Symbol.iterator]= function(){\n    var keys = Object.keys(this) //获取到对象的所有简直\n    var index = 0;\n    var self = this; //next里的this不指向对象\n    return {\n        next: function(){\n            return index &lt; keys.length? {\n               value: self[keys[index++]],\n                done: false\n            } : {\n                value: undefined,\n                done: true\n            }\n        }\n    }\n}\n\n\n```\nfor of会自动的调用遍历器方法,返回一个对象后,调用next方法\n</code></pre></blockquote>\n</li>\n<li><p>for(let <em>key</em> <strong>in</strong> arr) {} </p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>关于对象    </p>\n<ul>\n<li><p>对象键值可以用表达式,但一定要用方括号包起来,如<code>[&#39;a&#39;+1]: 1</code>也可以写成<code>[变量名]: 123</code>,  </p>\n<ul>\n<li>但是要<strong>注意</strong>,键值会被转成字符串,如[obj]: xxx中的键值会被转成<code>字符串格式的[Object object]</code></li>\n<li><strong><em>对象中的键名都是字符串</em></strong></li>\n</ul>\n</li>\n<li><p><code>Object.defineProperty(obj, prop, descriptor)</code>定义属性  </p>\n<ul>\n<li>关于第三个参数--描述符:数据属性(数据描述)/访问器属性(存取描述) <pre>\n{\nvalue: 该属性定义的值\nwritable: 默认false,是否可以被重新赋值\nenumerable: 是否可以被枚举,默认false\nconfigurable: 是否可以重新描述(重新配置这个描述符对象)以及是否可以删除该属性,默认false\n}\n{\nget: function() {return \"对应的属性值\"},取值的时候会触发get函数\nset: function() {},设置的时候会触发set函数\nenumerable: 是否可以被枚举,默认false\nconfigurable: 是否可以重新描述(重新配置这个描述符对象)以及是否可以删除该属性,默认false\n}\n</pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>spread(扩展运算符)<ul>\n<li>var arr1 = [1,2];<br> var arr2 = [3,4];<br> var newArr = [...arr1,...arr2]<br>  //[1,2,3,4]</li>\n<li>运用: 取最大值: Math.max.apply(null, arr); Math.max(...arr)/</li>\n<li>也可以把类数组(包括下面的Set数据结构也是一种类数组)转成数组,然后使用数组方法</li>\n</ul>\n</li>\n<li><p>函数</p>\n<ol>\n<li>默认参数: function(x,y=2) {}//设置参数y默认值为2,可以不传的参数要放在最后面,因为调用参数的时候,fn(1,,1)会报错  </li>\n<li>rest参数: function fn(a,...rt) =&gt; rt是一个数组,里边放着其他实参(相对于类型是<strong>类数组</strong>的arguments,是一个<strong>真正的</strong>数组)</li>\n<li><p>箭头函数: <code>var f = n =&gt; n+1</code>;</p>\n<ul>\n<li>等价于声明一个函数,参数是n,最后return n+1  </li>\n<li>复杂用法:<code>var f = (n,m) =&gt; {return n+m}</code>  </li>\n<li><p>关于this的指向: 箭头函数中this的指向是在定义的时候决定的,不是在定义的时候决定的,代码示例: </p>\n<pre><code class=\"lang-javascript\">  ele.onclick = function() {\n      setInterval(function() {\n          //这里的this指向window\n      }, 1000)\n      setInterval(()=&gt;{\n          //这里的this指向ele\n      }, 1000)\n  }\n</code></pre>\n</li>\n<li>箭头函数 不能当做构造函数,也不能使用arguments,(用<code>...rest</code>代替)</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>数据结构</p>\n<ul>\n<li>之前是[]和{}</li>\n<li>ES6新增了Set和Map<ul>\n<li>Set 类似数组打印出来是{1,2},但是成员的值都是唯一的,不允许有重复项<br>   代码: var set = new Set();<ol>\n<li>set.add(1) 通过add添加数据,重复添加相同的值是无效的  </li>\n<li>set.size 长度</li>\n<li>set.delete(4)</li>\n<li>set.has(4)</li>\n<li>set.clear()</li>\n<li>可以用作数组去重 var set = new Set([1,2,1,2,3,3])</li>\n</ol>\n</li>\n<li>Map 类似对象的键值对集合,但是键值不限于字符串,各种类型的值都可以<ul>\n<li>map.set(objKey, value)</li>\n<li>map.get(objKey)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Promise对象: 异步编程的解决方案(三种状态: pending,resolve,reject)</p>\n<ol>\n<li>应用: 可以把异步ajax请求从原来的多层嵌套转换为<strong>扁平化</strong></li>\n<li>新建对象: var p = new Promise(function(resolve, reject){\n resolve(...);想让他执行.then里成功的方法\n reject(...);想让他执行.then里失败的方法\n});</li>\n<li>p.then(function(...){成功的时候执行}, function(...){失败的时候执行}) 但这种方法不提倡,可读性不高\n所以一般把失败的处理函数写成: .catch(...){失败时执行}</li>\n</ol>\n</li>\n</ul>\n"
    }, {
        "id": 6,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"jquery-jquery-\">JQuery&amp;jQuery插件</h1>\n<ol>\n<li><code>$(document).ready(function(){})</code><br>简写为:<code>$(function(){})</code><br><em>注意: DOM节点全部加载进去才会触发(并不是资源加载完以后,所以不等价于window.onload)</em></li>\n<li>获取元素  <code>$(&#39;选择器&#39;)</code><em>有第二个参数,默认document,即从document下获取</em>,返回一个......</li>\n</ol>\n<a href=/?6 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"jquery-jquery-\">JQuery&amp;jQuery插件</h1>\n<ol>\n<li><code>$(document).ready(function(){})</code><br>简写为:<code>$(function(){})</code><br><em>注意: DOM节点全部加载进去才会触发(并不是资源加载完以后,所以不等价于window.onload)</em></li>\n<li>获取元素  <code>$(&#39;选择器&#39;)</code><em>有第二个参数,默认document,即从document下获取</em>,返回一个jq对象</li>\n<li>.click(为事件绑定事件处理函数)</li>\n</ol>\n<p><code>$(&quot;div&quot;)[1]</code>会返回原生元素(\\<div></div>)<br><code>$(&quot;div&quot;).eq(1)</code>会返回jq对象,可以直接用jq方法</p>\n<p>data和attr  </p>\n<ol>\n<li>传一个参数就是读取  </li>\n<li>传两个参数就是设置</li>\n</ol>\n<h4 id=\"index\">index</h4>\n<hr>\n<h2 id=\"-\">源码分析:</h2>\n<ol>\n<li><p>基本架构: </p>\n<pre><code class=\"lang-javascript\"> /*\n     在浏览器中运行jq文件，window是存在的\n     运行在nodejs中，是没有window的\n\n     把window传进去是为了性能考虑的\n */\n\n (function(global,factory){\n     factory(global);\n })(window,function (window,noGlobal){\n     //jQuery的源码    \n     console.log(&quot;我是源码，我被执行了&quot;);\n     //noGlobal的值为undefined\n     //在非严格模式下，undefined值可以被改写\n     var undefined = 123;\n     var abc;\n     console.log(abc ===  noGlobal );\n\n     //分析整体架构\n     var jQuery = function (){\n         //return new     jQuery();  //会循环调用\n         return new jQuery.fn.init();\n     };\n     //jQuery.fn是jQuery.prototype的别名\n     jQuery.fn = jQuery.prototype = {\n         constructor:jQuery,\n         each:function (){\n             console.log(&quot;我是each&quot;);\n         }\n     }\n     //可以定义另一个函数，作为构造函数\n     var init = jQuery.fn.init = function (){\n\n     }\n     //让init原型和jQuery的原型共同引用一个对象\n     init.prototype = jQuery.fn;\n     window.jQuery = window.$ = jQuery;\n });\n //console.log( new $().css );\n //在jquery中用的时候，无new的实例化过程\n //这样调用each方法，调用的是init.prototype上的方法\n $().each();\n</code></pre>\n</li>\n<li><p>链式调用的原理是每个方法返回的都是jquery对象</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"-jquery-\">关于JQuery插件</h2>\n<h4 id=\"-\">基于两个方法:</h4>\n<ol>\n<li><p>$.extend([deep], target, object1, [objectN])</p>\n<ul>\n<li>写了target是正常功能,即把obj扩展到target里  </li>\n<li><p>不写target的话就是扩展到自己的命名空间里</p>\n<blockquote>\n<pre><code>自己封装的深复制: \n\n```javascript\nfunction extend(obj){\n    //先判断传入参数的类型是数组还是对象  [] {}\n    var target = obj.constructor === Array ? [] : {};\n\n\n    for( var attr in obj ){\n        //判断一下obj[attr]是否是对象类型的，如果是，把obj[attr]也赋值一份\n\n        if(typeof obj[attr] === &quot;object&quot;){\n            //递归地复制找到的任何对象\n            target[attr] = extend(obj[attr]);\n        }else{\n            target[attr] = obj[attr];\n        }\n    }\n\n    return target;\n\n}\n</code></pre><p>   ```</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>$().extend(obj)</li>\n</ol>\n<h4 id=\"-\">书写格式:</h4>\n<ul>\n<li><p>匿名函数自执行,把jQuery传进去</p>\n<pre><code class=\"lang-javascript\">  (function ($){\n      $.fn.extend({\n          drag1:function (){\n              console.log(&quot;drag1&quot;);    \n          },\n          drag2:function (){\n              console.log(&quot;drag2&quot;);    \n          },\n          a:10\n      })\n\n      $.extend({\n          dialog1:function (){\n              console.log(&quot;dialog1&quot;);    \n          },\n          dialog2:function (){\n              console.log(&quot;dialog2&quot;);    \n          }\n      })\n  })(jQuery);\n</code></pre>\n</li>\n</ul>\n<h4 id=\"-jqdom-\">一个插件样例(功能: 高亮一组jqDOM元素):</h4>\n<p>声明:</p>\n<pre><code class=\"lang-javascript\">//闭包限定命名空间\n(function ($) {\n    $.fn.extend({\n        &quot;highLight&quot;: function (options) {\n            //检测用户传进来的参数是否合法\n            if (!isValid(options))\n                return this;\n            var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数\n            return this.each(function () {  //这里的this 就是 jQuery对象。这里return 为了支持链式调用\n                //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。\n                var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom\n                //根据参数来设置 dom的样式\n                $this.css({\n                    backgroundColor: opts.background,\n                    color: opts.foreground\n                });\n                //格式化高亮文本\n                var markup = $this.html();\n                markup = $.fn.highLight.format(markup);\n                $this.html(markup);\n            });\n\n        }\n    });\n    //默认参数\n    var defaluts = {\n        foreground: &#39;red&#39;,\n        background: &#39;yellow&#39;\n    };\n    //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。\n    $.fn.highLight.format = function (str) {\n        return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;;\n    }\n    //私有方法，检测参数是否合法\n    function isValid(options) {\n        return !options || (options &amp;&amp; typeof options === &quot;object&quot;) ? true : false;\n    }\n})(window.jQuery);\n</code></pre>\n<p>调用</p>\n<pre><code class=\"lang-javascript\">//调用\n        //调用者覆盖 插件暴露的共公方法\n        $.fn.highLight.format = function (txt) {\n            return &quot;&lt;em&gt;&quot; + txt + &quot;&lt;/em&gt;&quot;\n        }\n        $(function () {\n            $(&quot;p&quot;).highLight({ foreground: &#39;orange&#39;, background: &#39;#ccc&#39; }); //调用自定义 高亮插件\n        });\n</code></pre>\n"
    }, {
        "id": 7,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"js-\">js函数与变量同名(涉及到预解析和权重的问题)</h1>\n<pre><code class=\"lang-javascript\">console.log(a);\nvar a = 3;\nfunction a(){}\n输出的结果是：[Function: a]\n</code></pre>\n<p>注意一下几点就能知道原因了！</p>\n<ol>\n<li>函数声明会置顶</li>\n<li>变量声明也会置顶</li>\n<li><strong>函数声明比变量声明更置顶：）</strong></li>\n<li>变量和赋值语句一起书写，在......</li>\n</ol>\n<a href=/?7 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"js-\">js函数与变量同名(涉及到预解析和权重的问题)</h1>\n<pre><code class=\"lang-javascript\">console.log(a);\nvar a = 3;\nfunction a(){}\n输出的结果是：[Function: a]\n</code></pre>\n<p>注意一下几点就能知道原因了！</p>\n<ol>\n<li>函数声明会置顶</li>\n<li>变量声明也会置顶</li>\n<li><strong>函数声明比变量声明更置顶：）</strong></li>\n<li>变量和赋值语句一起书写，在js引擎解析时，会将其拆成声明和赋值2部分，声明置顶，赋值保留在原来位置</li>\n<li><strong>声明过的变量不会重复声明</strong></li>\n</ol>\n<p>按以上的规则代码等价为</p>\n<pre><code class=\"lang-javascript\">function a(){}\nvar a;//实际无效\nconsole.log(a);\na = 3;\n</code></pre>\n"
    }, {
        "id": 8,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"js-dom-mdn-\">js的兼容性(去DOM MDN全面学习)</h1>\n<blockquote>\n<p>各浏览器的内核</p>\n<ol>\n<li>IE--Trident</li>\n<li>Firefox--Gecko</li>\n<li>Safari, Chrome---webkit</li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>tips:</strong>\n如何判断浏览器是否支持某方法?\n`console.log(document.getElementsByClassName),......</p>\n</blockquote>\n<a href=/?8 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"js-dom-mdn-\">js的兼容性(去DOM MDN全面学习)</h1>\n<blockquote>\n<p>各浏览器的内核</p>\n<ol>\n<li>IE--Trident</li>\n<li>Firefox--Gecko</li>\n<li>Safari, Chrome---webkit</li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>tips:</strong>\n如何判断浏览器是否支持某方法?\n<code>console.log(document.getElementsByClassName),</code> \n如果是undefined,就是不支持</p>\n<p>火狐下只有用window.open()打开的窗口,才能用window.close()关掉</p>\n</blockquote>\n<ol>\n<li>低版本IE(9以下,9是标准的)不支持:<br> getElementsByClassName/<br> getComputedStyle(a,b)[currentStyle]/<br> 数组的indexOf,forEach,trim方法/<br> addEventListener/<br> bind/<br> ajax对象(IE6用new ActiveXObject(&quot;Microsoft XMLHTTP&quot;)来代替)/<br> ajax的onload事件(IE6用onreadystatechange事件,检测readyState属性为4或者状态码为200来代替)</li>\n<li>低版本IE支持 :getElementsByTagName/call,apply</li>\n</ol>\n<hr>\n<p><strong>getElementByClassName兼容性解决</strong></p>\n<pre><code class=\"lang-javascript\">    if(document.getElementsByClassName) {\n        支持,正常使用\n    } else {\n        var all = document.getElementByTagName(&#39;*&#39;);\n        for(var a = 0, a&lt; all.length, a++) {\n            if(all[i].className.split(&quot; &quot;).indexOf(&quot;class名&quot;)\n        }\n    }\n</code></pre>\n<p><strong>indexOf兼容性解决</strong></p>\n<pre><code class=\"lang-javascript\">    function indexOf(arr, str) {\n        for(var i=0; i&lt;arr.length, i++) {\n            if(arr[i] === str) {\n                return i;\n            }\n        }\n        return -1;\n    }\n</code></pre>\n<p><strong>getComputedStyle兼容性解决</strong></p>\n<pre><code class=\"lang-javascript\">    ele.currentStyle.width\n    等价于高版本的\n    getComputedStyle(ele).width/  getComputedStyle(ele,&#39;width&#39;)\n</code></pre>\n<hr>\n<p>事件对象:  </p>\n<ol>\n<li><p><strong>IE高版本:</strong><br>事件对象作为事件处理函数的第一个参数\n同时全局提供一个event变量(火狐没有这个全局变量)</p>\n</li>\n<li><p><strong>IE低版本:</strong><br>只能通过全局的event对象</p>\n</li>\n</ol>\n<p>兼容处理:\nele.onclick = function(ev) {\n    var e = ev||window.event\n}</p>\n<hr>\n<p><strong>IE低版本<code>add/remove EventListener</code>不兼容解决</strong>\n<code>element.attachEvent(on+evName,evfn)</code> //不能捕获,只能冒泡<br><code>element.detachEvent(on+evName,evfn)</code> //不能捕获,只能冒泡<br>低版本的this是window,这个问题用call解决(bind也不支持)</p>\n"
    }, {
        "id": 9,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"svg\">SVG</h1>\n<p>是基于xml的技术\nxml可以自定义标签,html的标签是固定的</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&#39;1.0&#39; encoding=&quot;utf-8&quot;&gt;\n&lt;!DOCTYPE svg .....&gt;\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\n</code></pre>\n<p>把svg(xml文件)引入html的方法:</p>\n<p>```html</p>\n<ol>\n<li>&lt;im......</li>\n</ol>\n<a href=/?9 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"svg\">SVG</h1>\n<p>是基于xml的技术\nxml可以自定义标签,html的标签是固定的</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&#39;1.0&#39; encoding=&quot;utf-8&quot;&gt;\n&lt;!DOCTYPE svg .....&gt;\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\n</code></pre>\n<p>把svg(xml文件)引入html的方法:</p>\n<pre><code class=\"lang-html\">1. &lt;img src=&#39;1svg.svg(xml其实不管后缀名的)&#39;/&gt;\n2. &lt;div style=&quot;background:url(1svg.svg)&quot;&gt;\n3. &lt;iframe src=&#39;1svg.svg&#39;&gt;&lt;/iframe&gt;\n</code></pre>\n<hr>\n<p>在html5中:\n可以在html中直接写</p>\n<p>```html</p>\n<p><svg id=\"svg1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">\n    <!--底下所有坐标都是相对于svg标签的父级的坐标-->\n    <!--画圆-->\n    &lt;circle \n        cx=&quot;圆心坐标x(不带单位)&quot; \n        cy=&quot;圆心坐标y(不带单位)&quot; \n        r=&quot;半径(不带单位)&quot; </p>\n<pre><code>    //也可以把下面样式键值对写到style属性里\n    fill=&quot;填充颜色&quot; \n    stroke=&quot;边框颜色&quot;\n    stroke-width=&quot;边框宽度(不带单位)&quot;\n&gt;\n&lt;/circle&gt;\n&lt;!--画矩形--&gt;\n&lt;rect \n    width=&quot;200&quot; \n    height=&quot;200&quot; \n    x=&quot;100(左上角坐标)&quot; \n    y=&quot;100&quot; \n    fill=&quot;填充颜色&quot; \n    rx=&quot;圆角半径x&quot; ry=&quot;圆角半径y&quot;(也可以只写一个)\n&gt;&lt;/rect&gt;\n&lt;!--划线--&gt;\n&lt;line\n    x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot;//两个端点的坐标\n    stroke=&quot;线条颜色&quot;\n    stroke-width=&quot;线条粗细&quot;\n    stroke-opacity=&quot;.5(线条透明度)&quot;\n&gt;&lt;/line&gt;\n&lt;!--g标签:是一个容器标签,用来包裹一组元素,可以对子元素进行统一操作--&gt;\n&lt;g stroke-width这些共用属性可以设置然后子类自动继承 也可以用transform:translate(0,0)达到整体平移的效果&gt;\n    &lt;circle&gt;&lt;/circle&gt;\n    ...\n&lt;/g&gt;\n&lt;!--文字--&gt;\n&lt;text \n    x=&quot;文字基点位置坐标x&quot; y=&quot;文字位置坐标y&quot; \n    font-size=&quot;&quot; \n    text-anchor=&quot;middle(左右居中(关于前面设置坐标基点对称))/start/end&quot;\n&gt;文字&lt;/text&gt;\n&lt;!--图片--&gt;\n&lt;image\n    x=&quot;左上角坐标x&quot;\n    y=&quot;左上角坐标y&quot;\n    width=&quot;&quot;\n    height=&quot;&quot;\n    xlink:href=&quot;img/main.png(图片url)&quot;\n&gt;&lt;/image&gt;\n&lt;!--折线--&gt;\n&lt;polyline\n    points=&quot;50 50 200 300 230 230(每个点的坐标)&quot; (可以用空格隔开,也可以用逗号隔开)\n    stroke=&quot;black&quot; \n    stroke-width=&quot;4&quot; \n    fill=&quot;none&quot;(不设置会默认用黑色填充)\n&gt;&lt;/polyline&gt;\n&lt;!--多边形(与折线区别就是他是闭合的)--&gt;\n&lt;polygon&gt;&lt;/polygon&gt;\n&lt;!--path路径--&gt;\n&lt;path\n    d=&quot;M50 100L200 200L20 30H200V100Z&quot;\n    //M是绘制起点\n    //L是途经点\n    //Z是首尾闭合(要写在最后)\n    //H是水平绘制\n    //V是垂直绘制\n    //A绘制弧线\n        - X半径长度\n        - Y半径长度\n        - 角度(针对椭圆,正圆直接写0就好)\n        - 弧长: 0 小弧 1 大弧\n        - 方向: 0 逆时针 1 顺时针\n        - 终点X坐标\n        - 终点Y坐标\n    //字母区分大小写,小写意味着是长度(相对坐标),大写是坐标(绝对坐标)\n&gt;&lt;/path&gt;\n</code></pre><svg>\n\n<hr>\n<script>\n使用js动态生成\n\n1. 生成标签\nvar oSvg = document.createElementNS(\n    两个参数: \n        1. \"命名空间\"\n        2. (标签名)\"svg\"/\"circle\"/\"line\"...\n)\n2. 设置属性\noSvg.setAttribute(\"xmlns\",\"命名空间\")\noSvg.setAttribute(\"width\",\"100%\")\noSvg.setAttribute(\"height\",\"100%\")\n3. append到容器div里\noParent.appendChild(oSvg)\n\n</script>\n\n<ol>\n<li>运动\n<animate attributeName=\"width\" dur=\"1\" from=\"50\" to=\"100\">宽度1s从50到100</li>\n</ol>\n"
    }, {
        "id": 10,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"tips\">Tips</h1>\n<ol>\n<li><p>如果既想外联又想把js写在body的最后面,就这么写: </p>\n<p> ```html\n&lt;!DOCTYPE html&gt;\n<html>\n <head></p>\n<pre><code> &lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;&lt;/title&gt;\n &lt;link rel=&quot;stylesheet&quot; href=&quot;xx.css&quot;&gt;\n</code></pre><p> </head>\n <body></p>\n<pre><code> ..........\n</code></pre></li>\n</ol>\n<a href=/?10 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"tips\">Tips</h1>\n<ol>\n<li><p>如果既想外联又想把js写在body的最后面,就这么写: </p>\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n &lt;head&gt;\n     &lt;meta charset=&quot;UTF-8&quot;&gt;\n     &lt;title&gt;&lt;/title&gt;\n     &lt;link rel=&quot;stylesheet&quot; href=&quot;xx.css&quot;&gt;\n &lt;/head&gt;\n &lt;body&gt;\n     ....\n     &lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</li>\n<li><p><code>getElementById(&quot;xx&quot;)</code>,找不到会返回null</p>\n</li>\n<li>变量命名规范:<ul>\n<li>组成:数字,字母,下划线,$</li>\n<li>开头:非数字</li>\n<li>不许使用关键字,保留字</li>\n</ul>\n</li>\n<li><p>内层循环的语句想直接跳出外层循环</p>\n<pre><code class=\"lang-javascript\"> a:for(var i = 0;i&lt;2;i++){//为外层的for取个名字a\n     for(var j = 0;j&lt;3;j++){\n         if(j == 1){\n             break a;//跳出的是名为a的 for循环，for循环内部后面的代码都不执行了\n         }\n         alert(&quot;i是：&quot;+i+&quot;,j是：&quot;+j);\n     }\n }\n</code></pre>\n</li>\n<li></li>\n</ol>\n"
    }, {
        "id": 11,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"vue-\">Vue(全自动版模板引擎)</h1>\n<p><em>双向绑定: 修改数据,自动同步修改DOM</em><br><em>注意: Vue是在浏览器解析DOM后才获取到元素进行修改的</em>  </p>\n<p>使用方法: </p>\n<p>```javascript\n<strong>View部分</strong>\n//关于&#39;指令&#39;:写在html元素上的自定义属性,以&#39;v-&#39;开头</p>\n<p>&lt;div id=&#39;box&#39; v-if=&quot;onoff&quot;(里边onoff是true的时候就增加上,是f......</p>\n<a href=/?11 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"vue-\">Vue(全自动版模板引擎)</h1>\n<p><em>双向绑定: 修改数据,自动同步修改DOM</em><br><em>注意: Vue是在浏览器解析DOM后才获取到元素进行修改的</em>  </p>\n<p>使用方法: </p>\n<pre><code class=\"lang-javascript\">**View部分**\n//关于&#39;指令&#39;:写在html元素上的自定义属性,以&#39;v-&#39;开头\n&lt;div id=&#39;box&#39; v-if=&quot;onoff&quot;(里边onoff是true的时候就增加上,是false就删掉(增删DOM元素)) v-show=&quot;onoff&quot;(里边onoff是true的时候就显示,是false就隐藏(修改css的display))&gt;\n    &lt;div&gt;{{message}}&lt;/div&gt;\n    &lt;div&gt;{{c_mes}}&lt;/div&gt;\n    &lt;li v-for=&quot;val(,ind如果用得到索引值的时候) of(或in) list&quot;&gt;{{val.title}}&lt;/li&gt;\n    &lt;input id=&quot;addInfo&quot; v-on:keyup=&quot;addInfo&quot;(可以简写为@keyup.13\n        //.13是事件修饰符(代表keyCode),  \n        //还有.enter之类的,相当于直接把过滤规则写在这里,就不需要写在函数里了*/) \n        //v-model=&quot;value&quot; \n        //v-bind(可以简写为:,使用数据动态绑定给自定义属性):abc=&quot;mes&quot;//class=&quot;{class名:布尔值}&quot;表示通过对应的布尔值确定要不要加class&quot;\n    /&gt;\n    //在绑定事件处理函数的时候有两种方法:            //@click=&quot;fn&quot;//@click=&quot;fn()&quot;    \n    //第一种方法调用的时候第一个参数就是事件对象,\n    //第二个方法第二个参数是事件对象\n    &lt;p&gt;同步表单value值改变: {{value}}&lt;/p&gt;\n&lt;/div&gt;\n\n`v-show不支持&lt;template&gt;`\n                &lt;template v-if....&gt;\n                    &lt;li&gt;&lt;/li&gt;\n                &lt;/template&gt;\n\n\n&lt;p v-if=&quot;&quot;&gt;条件一满足&lt;/p&gt;\n&lt;p v-else-if=&quot;&quot;&gt;条件二满足&lt;/p&gt;\n&lt;p v-else=&quot;&quot;&gt;所有条件都不满足&lt;/p&gt;\n!!!注意,这种用法必须紧挨着\n\n**Module部分**\nvar dataArr = [\n    {\n        title: xx,\n        id: 0\n    },\n    {\n        title: xx,\n        id: 0\n    },\n    ...\n]\n\n\n**VM部分**\n//根实例,传入一个选项参数\nnew Vue({\n    el(挂载点: 值可以是选择器字符串,也可以是DOM对象):&#39;#box&#39;//此时id为box的标签下的所有元素,都归vue管理\n    data(这里的属性都是挂载在根实例上的): {\n        message: &quot;Hello Vue&quot;,\n        list: dataArr,\n        value: &quot;&quot;//这个值会实时同步此刻的value值,\n        mes: &quot;xx&quot;,\n        onoff: true\n    }\n\n    methods: {//放置所有函数,包括事件处理函数\n        addInfo: function(){\n            //里边的this指向Vue对象(根实例),所以通过this.list就可以找到数据(Module),然后用push之类的方法就可以更新数据\n        };\n        xxx(如双击事件): function() {\n            想获取到渲染后的DOM结构的某个元素 并操作,  \n             步骤如下: \n             1. 给要获取的元素html标签里加一个自定义属性ref  :ref=&quot;xxx&quot;;\n             2. 然后要获取到修改数据同步渲染完结构后的那一刻触发事件的事件处理函数this.$nextTick(function(){//这里写这一刻要做的事,!!一定要写!!})\n             3. 然后在函数体里,获取到vue对象上的一个自带属性vm(或者this也可以).$refs,对应的值是一个对象,里边放着所有有ref属性的html元素的DOM对象,然后通过ref对应的属性值[&#39;ref属性值xxx&#39;],找到这些特定元素的小集合,然后通过[0(下标)]就可以取出来进行操作\n        }\n    }\n\n    computed(计算后属性): {\n        c_mes: function() {\n            return 数据处理逻辑写在这里\n        },\n\n        //如果想添加c_mes的读/写方法\n        c_mes: {\n            get() {\n            },\n            set(newVal) {\n            }\n        }\n    }\n\n    watch(监控器): {\n\n        //默认浅度监控\n        beWatched: function() {}//只要(data对应的对象里)的(key值对应)的值发生改变,就会触发该函数\n        //开启深度监控\n        xxx: {\n            handler:function(){},\n            deep: true \n        }\n    }\n})\n</code></pre>\n<p>! 注意: 行间js\\<div onclick = \"fn()\">而不是=&quot;fn&quot;\n! 注意: 命名规范,遇到一个,<strong><em>方法名不能叫delete</em></strong></p>\n<h2 id=\"-\">三种模板</h2>\n<ol>\n<li><p>html模板</p>\n<pre><code class=\"lang-html\"> &lt;!--视图V--&gt;\n &lt;div v-html=&#39;innerHtml&#39;&gt;\n\n &lt;!--数据--&gt;\n var vm = new Vue({\n     el:xx,\n     data: {\n         innerHtml: &quot;&lt;div&gt;xxx&lt;/div&gt;&quot;\n     }\n })\n</code></pre>\n</li>\n<li><p>template</p>\n<p> 两种方法: </p>\n<ol>\n<li><p>字符串模板做选项对象中template的值</p>\n<p> ```html</p>\n <!--视图V-->\n<p> <div id=\"box\" v-html='innerHtml'><div></p>\n <!--数据m-->\n<p> innerHtml: &quot;<div>xxx</div>&quot;(注意: 只能有一个根节点)\n let obj = {</p>\n<pre><code> ...\n</code></pre><p> }</p>\n</li>\n</ol>\n</li>\n</ol>\n<pre><code>    &lt;!--vm--&gt;\n    var vm = new Vue({\n        el:&#39;#box&#39;,\n        data: obj,\n        template: innerHtml(注意: 会完全替换挂载点元素)\n    })\n\n    ```\n2. script标签存放模板(类似模板引擎)(两点注意: type和id)\n\n    ```html\n    &lt;!--视图V--&gt;\n    &lt;div id=&quot;box&quot; v-html=&#39;innerHtml&#39;&gt;&lt;div&gt;\n\n    &lt;!--数据m--&gt;\n    &lt;script type=&#39;x-template&#39; id=&quot;temp&quot;&gt;&lt;div&gt;xxx&lt;/div&gt;&lt;/script&gt;\n\n    let obj = {\n        ...\n    }\n\n\n    &lt;!--vm--&gt;\n    var vm = new Vue({\n        el:&#39;#box&#39;,\n        data: obj,\n        template: &#39;#temp&#39;(注意: 会完全替换挂载点元素)\n    })\n    ```\n</code></pre><ol>\n<li><p>render模板</p>\n<pre><code> 编译的时候,编译器会吧模板里的html标签拿出来,都调用一遍render函数\n\n ```html\n &lt;!--视图V--&gt;\n &lt;div id=&quot;box&quot; v-html=&#39;innerHtml&#39;&gt;&lt;div&gt;\n\n &lt;!--数据m--&gt;\n</code></pre></li>\n</ol>\n<pre><code>    let obj = {\n        ...\n    }\n\n\n    &lt;!--vm--&gt;\n    var vm = new Vue({\n        el:&#39;#box&#39;,\n        data: obj,\n        render: function(createElement){//这个参数实际上就是一个创建元素的方法\n        //语法: createElement(标签名,[数据对象(包括id, class,或自定义属性)],子元素(文本或数组)),这个函数就会返回一个虚拟DOM(VNode)\n\n            return createElement(\n                &quot;ul&quot;(标签名), \n\n                {  //选项(数据)对象\n                    class: { //类似v-bind:class={&#39;class&#39;: true}\n                        class名: 布尔值\n                    },\n                    style: {\n                        fontsize: &#39;90px&#39;\n                    },\n                    attrs: {\n                        自定义属性名: &quot;属性值&quot;\n                    },\n                    domProps: {\n                        //DOM对象身上的属性\n                        innerHTML: &#39;&lt;li&gt;xx&lt;/li&gt;&#39;//这条指令的权重较高,底下传的第三个参数就无效了\n                        value: xxx\n                        ...\n                    },\n                    on: {\n                        绑定事件\n                    }\n\n                },\n\n\n                [\n                    createElement(&#39;li&#39;,数据1),\n                    createElement(&#39;li&#39;,数据2),\n                    createElement(&#39;li&#39;,数据3)\n                ](子元素数组,也可以是单个的就不必要携写成数组了)\n\n            )\n        }\n    })\n    ```\n</code></pre><h2 id=\"-\">组件(组合的视图组件)</h2>\n<p>比如在布局时,可能很多页面都有相同的一块结构,所以把这些具有可复用性的代码块做成组件,比如<strong>element</strong></p>\n<p>每个框架都有自己的实现方法</p>\n<p>vue里是通过自定义标签来实现的</p>\n<p>步骤: </p>\n<ol>\n<li><p>注册组件: 全局注册/局部注册    </p>\n<ol>\n<li><p>Vue.component(&#39;custom-comp&#39;[自定义标签的名字],                         {</p>\n<pre><code>              template: &#39;只能有一个根元素,传参可以直接用{{props里的属性名}}&#39;[结构字符串]\n              props: [&#39;标签里定义的属性1&#39;,&#39;属性2&#39;...,(可以直接用vm实例data里的key值)]\n              data: function(){return {里边放自定义的数据}}//要求写成函数是因为如果写成一个对象,那就意味着多个组件共用一个对象,牵一发而动全身,用函数的时候,每次return一个新的对象\n             }[选项对象]);\n             methods: ...这些都有\n</code></pre></li>\n<li><p>特殊的,对于一些受限元素,如ul,table, a之类的只能嵌套特定的元素的标签,浏览器在解析时,会有容错功能,嵌套不合理标签的时候,会把这个标签摘出去到与受限元素平行关系的位置</p>\n</li>\n<li><p>既可以注册一个新标签,也可以放在原生html元素上,由于限制嵌套,所以可以用is,代码示例: </p>\n<pre><code class=\"lang-html\"> &lt;!--方法一--&gt;\n &lt;custom-comp&gt;&lt;/custom-comp&gt;\n\n &lt;!--方法二--&gt;\n 这种方法是不对的,因为浏览器解析时会把里边的不符合规定的元素摘出来\n &lt;ul&gt;\n     &lt;custom-comp&gt;&lt;/custom-comp&gt;\n &lt;ul&gt;\n\n 所以要用is\n &lt;ul&gt;\n     &lt;li is=&quot;custom-comp&quot;&gt;&lt;/li&gt;\n &lt;/ul&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n"
    }, {
        "id": 12,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">事件</h1>\n<ol>\n<li>滚轮事件:\n IE,chrome<br> onmousewheel</li>\n</ol>\n<pre><code>火狐下\n只能通过addEventListener(&#39;DOMMouseScroll&#39;)来绑定\n\n没记太清楚,找老师课件看一下\n</code></pre><p>2.......</p>\n<a href=/?12 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">事件</h1>\n<ol>\n<li>滚轮事件:\n IE,chrome<br> onmousewheel</li>\n</ol>\n<pre><code>火狐下\n只能通过addEventListener(&#39;DOMMouseScroll&#39;)来绑定\n\n没记太清楚,找老师课件看一下\n</code></pre><p>2. </p>\n"
    }, {
        "id": 13,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-checkbox\">关于 checkBox</h1>\n<p><strong>有两个意向</strong></p>\n<ol>\n<li><p><code>&lt;input type=&quot;checkbox&quot; checked/&gt;</code><br> //只要有这个行间属性(不管是什么值),就会是一个框选的效果</p>\n</li>\n<li><p>DOM对象的checked属性:<br> var cb = document.getElementById(&quot;cb&quot;);<br> <code>cb.checked</code> //这个属性表征选框的当前状......</p>\n</li>\n</ol>\n<a href=/?13 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-checkbox\">关于 checkBox</h1>\n<p><strong>有两个意向</strong></p>\n<ol>\n<li><p><code>&lt;input type=&quot;checkbox&quot; checked/&gt;</code><br> //只要有这个行间属性(不管是什么值),就会是一个框选的效果</p>\n</li>\n<li><p>DOM对象的checked属性:<br> var cb = document.getElementById(&quot;cb&quot;);<br> <code>cb.checked</code> //这个属性表征选框的当前状态,到底有没有选中<br> 也可以通过修改这个属性,来达到不点击选框就勾选的效果</p>\n</li>\n</ol>\n"
    }, {
        "id": 14,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-git-github\">关于git/github</h1>\n<p>是一种分散性管理控制系统</p>\n<blockquote>\n<p>名词解释\nfork: 将github里某个仓库<strong>复制</strong>到自己的账户下<br>follow: 关注别人<br>clone: 将已有仓库克隆到本地\nadd: 把新建出来的文件添加到(个人理解的)追踪列表里<br>commit: 将代码提交到本地git(记录工作树中所有文件的当前状态)\npush: 将代码同步到github</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>-......</p>\n</blockquote>\n<a href=/?14 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-git-github\">关于git/github</h1>\n<p>是一种分散性管理控制系统</p>\n<blockquote>\n<p>名词解释\nfork: 将github里某个仓库<strong>复制</strong>到自己的账户下<br>follow: 关注别人<br>clone: 将已有仓库克隆到本地\nadd: 把新建出来的文件添加到(个人理解的)追踪列表里<br>commit: 将代码提交到本地git(记录工作树中所有文件的当前状态)\npush: 将代码同步到github</p>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>集中型版本控制:只有一个仓库,存放在服务器中,集中管理,开发者连接不上服务器或者服务器故障,就会影响编程</li>\n<li>分散型版本控制: 拥有多个仓库,相对而言较复杂,不过,由于本地开发环境中就有仓库,所以开发者可以不必连接远程仓库就可以进行开发</li>\n</ul>\n</blockquote>\n<hr>\n<p>配置步骤:\n<code>$git config --global user.name &quot;Firstname Lastname&quot;</code>\n<code>$git config --global user.email &quot;your_email@example.com&quot;</code>\n<em>这两个用户信息只是写入提交日志的,存储在git配置文件.gitconfig中的,和github没有关系</em><br><code>$ git config --global color.ui auto</code><br> 命令高亮显示,提高可读性</p>\n<hr>\n<p> SHH key:\n github上,连接已有仓库时的认证,是通过使用了SSH的公开密钥(yue)认证的方式进行的,\n 创建方法: </p>\n<pre><code class=\"lang-shell\">$ ssh-keygen -t rsa -C &quot;your_email@example.com(github使用的邮箱)&quot;   \nGenerating public/private rsa key pair.  \nEnter file in which to save the key  \n(/Users/your_user_directory/.ssh/id_rsa): 按回车键  \nEnter passphrase (empty for no passphrase): 输入密码  \nEnter same passphrase again: 再次输入密码\n</code></pre>\n<p>会返回</p>\n<blockquote>\n<p>Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.<br>Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub. The key fingerprint is:<br><code>fingerprint值</code> your_email@example.com   The key&#39;s randomart image is:<br>+--[ RSA 2048]----+<br>|      .+ +       |<br>| =oO. |</p>\n</blockquote>\n<p><em>其中id_rsa文件是私钥,id_rsa.pub是公开密钥</em></p>\n<p>然后把公钥添加入github里,以后就可以用私有密钥进行认证了<br>公钥内容查看指令: \n<code>$ cat ~/.shh/id_rsa.pub</code><br>也可以把那个文件拖入chrome打开,然后复制</p>\n<p>测试是否匹配(是否配置成功)<br><code>$ ssh -T git@github.com</code></p>\n<p>配置完成后,就可以使用手里的私钥与github进行认证和通信了</p>\n<hr>\n<p>配置完成后开始使用<br>创建仓库时,如果勾选了用README.md初始化仓库,就可以直接克隆了,但是如果想把本地的git添加进去,就不要勾选,直接手动push</p>\n<p>clone(克隆仓库):\n<code>$ git clone xxxx(从github插到仓库的ssh或https地址)</code></p>\n<p>在本地仓库文件夹新建一个文件后,该文件初始是Untracked files(未被跟踪的文件)的状态\n通过<code>$ git status</code>可以查看git状态<br><code>$ git add 新建出来的文件</code>add指令用来把新建出来的文件添加到追踪列表里(</p>\n<blockquote>\n<pre><code>官方解释: 新建文件只是在工作树中创建了,该文件并不会被记入git仓库的版本管理**对象**中,add命令将其加入到暂存区(提交之前的一个临时区域)\n</code></pre></blockquote>\n<p>)<br><code>$ git commit -m &quot;提交描述summary&quot;</code>提交到本地git<br>提交成功后可以通过<code>$ git log</code>来查看提交日志</p>\n<p>之后通过<code>$ git push</code>就可以把代码同步到github(网上)</p>\n<hr>\n<p>实际操作: \n<code>git init</code>---初始化仓库</p>\n<blockquote>\n<p><code>$ mkdir xxx新建文件夹名</code>----该指令用来新建文件夹(默认建在根目录(mac是username文件夹下))\n<code>cd xxx</code>\n<code>$ git init</code>\n该初始化指令成功后会在xxx文件夹里生成一个.git文件夹,里边存储着仓库数据(术语: 附属于该仓库的工作树),文件的新建,编辑等操作在工作树中进行,然后记录到仓库中,以此管理文件的历史快照</p>\n</blockquote>\n<p><code>git status</code>----查看仓库的状态</p>\n<blockquote>\n<p>显示git仓库的状态(很常用)\n只要对git的工作树或者仓库进行操作,该命令的显示结果就会发生变化</p>\n</blockquote>\n"
    }, {
        "id": 15,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-jq-on-click-selector-\">关于jq中事件绑定函数(on,或click之类)的第二个参数selector的用法</h1>\n<p>文档中是这么说的:  </p>\n<h5 id=\"-on-events-selector-data-fn-\"><code>on(events,[selector],[data],fn)</code></h5>\n<p><em>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择的&lt; null或省略，当它到达选定的元素，事件总是触发。</em></p>\n<p>**所以这个参数应该是一个字符串,而且应......</p>\n<a href=/?15 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-jq-on-click-selector-\">关于jq中事件绑定函数(on,或click之类)的第二个参数selector的用法</h1>\n<p>文档中是这么说的:  </p>\n<h5 id=\"-on-events-selector-data-fn-\"><code>on(events,[selector],[data],fn)</code></h5>\n<p><em>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择的&lt; null或省略，当它到达选定的元素，事件总是触发。</em></p>\n<p><strong>所以这个参数应该是一个字符串,而且应该是一个内容是选择器的字符串</strong></p>\n<hr>\n<p>示例代码:  </p>\n<p><strong>HTML部分:</strong></p>\n<pre><code class=\"lang-html\">&lt;div id=&quot;pg-box&quot;&gt;\n    &lt;a href=&quot;javascript:;&quot; class=&quot;home&quot;&gt;首页&lt;/a&gt;\n    &lt;a href=&quot;javascript:;&quot; class=&quot;prev&quot;&gt;上一页&lt;/a&gt;\n    &lt;span class=&quot;pages&quot;&gt;\n        &lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt;\n        &lt;a href=&quot;javascript:;&quot;&gt;2&lt;/a&gt;\n        &lt;a href=&quot;javascript:;&quot;&gt;3&lt;/a&gt;\n        &lt;a href=&quot;javascript:;&quot;&gt;4&lt;/a&gt;\n        &lt;a href=&quot;javascript:;&quot;&gt;5&lt;/a&gt;\n    &lt;/span&gt;\n    &lt;a href=&quot;javascript:;&quot; class=&quot;next&quot;&gt;下一页&lt;/a&gt;\n    &lt;a href=&quot;javascript:;&quot; class=&quot;end&quot;&gt;尾页&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n<p><strong>Javascript部分</strong></p>\n<pre><code class=\"lang-javascript\">$(&#39;#pg-box&#39;).on(&#39;click&#39;,&#39;a:not(.pages a)&#39;,evFn)\n</code></pre>\n<hr>\n<blockquote>\n<p><strong>分析:</strong></p>\n<ol>\n<li>需求:想要给页码1,2,3,4,5加点击事件处理函数 </li>\n<li>分析:虽然通过jq选择器<code>$(&#39;a&#39;).not($(&quot;.pages a&quot;))</code>可以选择到目标元素,但是分析文档,第二个参数要传的是一个<strong>选择器</strong>字符串,例如<code>&#39;a&#39;</code>,<code>&#39;.active&#39;</code>之类的<strong><em>选择器+字符串</em></strong></li>\n<li>所以要写成: <code>&#39;a:not(.pages a)&#39;</code>就好了</li>\n</ol>\n</blockquote>\n"
    }, {
        "id": 16,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-js-\">关于js的匿名函数与自执行</h1>\n<h2 id=\"-\">基本格式:</h2>\n<p><code>(function(x,y){alert(x+y)})(a,b)</code><br>第一个括号创建了一个匿名函数,<br>第二个括号调用了它并传入了参数<br>括号包起来就是表达式,不包括号就只是一个函数声明..这也就是为什么(funcrion(){})()可以被执行,而function(){}()却会报错</p>\n<blockquote>\n<p>(1). 首先, 要清楚两者......</p>\n</blockquote>\n<a href=/?16 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-js-\">关于js的匿名函数与自执行</h1>\n<h2 id=\"-\">基本格式:</h2>\n<p><code>(function(x,y){alert(x+y)})(a,b)</code><br>第一个括号创建了一个匿名函数,<br>第二个括号调用了它并传入了参数<br>括号包起来就是表达式,不包括号就只是一个函数声明..这也就是为什么(funcrion(){})()可以被执行,而function(){}()却会报错</p>\n<blockquote>\n<p>(1). 首先, 要清楚两者的区别:     (function {// code})是表达式, function {// code}是函数声明.<br>       (2). 其次, js&quot;预编译&quot;的特点:     js在&quot;预编译&quot;阶段, 会解释函数声明, 但却会忽略表式.<br>       (3). 当js执行到function() {//code}();时, 由于function() {//code}在&quot;预编译&quot;阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错; </p>\n<p>   当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.</p>\n<p>   另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符……</p>\n</blockquote>\n<h2 id=\"-closure-\">闭包(closure)</h2>\n<p><strong>优点</strong>: <em>可以大大减少我们的代码量,使我们的代码看上去更加清晰</em></p>\n<p><strong>概念</strong>: 函数的嵌套,根据作用域链,内层函数可以使用外层函数的变量,即使外层函数已经执行完毕<br><strong>典型代码示例</strong>: </p>\n<pre><code class=\"lang-javascript\">function checkClosure(){  \n    var str = &#39;rain-man&#39;;  \n    setTimeout(  \n        function(){ alert(str); } //这是一个匿名函数  \n    , 2000);  \n}  \ncheckClosure();\n</code></pre>\n<blockquote>\n<p>这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：  </p>\n<ol>\n<li>checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），  </li>\n<li>在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放  </li>\n<li>这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。</li>\n</ol>\n</blockquote>\n<pre><code class=\"lang-javascript\">var outer = null;  \n\n(function(){  \n    var one = 1;  \n    function inner (){  \n        one += 1;  \n        alert(one);  \n    }  \n    outer = inner;  \n})();  \n\nouter();    //2  \nouter();    //3  \nouter();    //4\n</code></pre>\n<blockquote>\n<p><strong>分析</strong>:   </p>\n<ol>\n<li>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。</li>\n<li>但是这里我们创建了inner函数，inner函数是可以访问变量one的；  </li>\n<li>又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。 \n<strong>很重要的一点:outer变量只是引用了函数</strong></li>\n</ol>\n</blockquote>\n<hr>\n<h1 id=\"-for-\">闭包在for循环中的应用</h1>\n<pre><code class=\"lang-javascript\">var divs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; divs.length; i++) {\n    tab(i);\n}\nfunction tab(n){\n    divs[n].onclick = function(){\n        alert(n);\n    }\n}\n</code></pre>\n<hr>\n<p>注意</p>\n<p>1 闭包允许内层函数引用父函数中的变量，但是该变量是最终值</p>\n<pre><code class=\"lang-javascript\">/**  \n * &lt;body&gt;  \n * &lt;ul&gt;  \n *     &lt;li&gt;one&lt;/li&gt;  \n *     &lt;li&gt;two&lt;/li&gt;  \n *     &lt;li&gt;three&lt;/li&gt;  \n *     &lt;li&gt;one&lt;/li&gt;  \n * &lt;/ul&gt;  \n */\n\nvar lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    lists[ i ].onmouseover = function(){  \n        alert(i);      \n    };  \n}\n</code></pre>\n<p>你会发现当鼠标移过每一个\\<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？  </p>\n<ol>\n<li>当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；  </li>\n<li>因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；  </li>\n<li>所以，最终每次弹出的都是4。  </li>\n</ol>\n<p><strong>解决方法一：</strong></p>\n<pre><code class=\"lang-javascript\">var lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    (function(index){  \n        lists[ index ].onmouseover = function(){  \n            alert(index);      \n        };                      \n    })(i);  \n}\n</code></pre>\n<p><strong>解决方法二：</strong></p>\n<pre><code class=\"lang-javascript\">function eventListener(list, index){  //相比于最开始的那种方法,这个函数更纯,不依赖外部变量\n    list.onmouseover = function(){  \n        alert(index);  \n    };  \n}  \nvar lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    eventListener(lists[ i ] , i);  \n}\n</code></pre>\n<hr>\n<p>2 内存泄露<br>使用闭包十分容易造成浏览器的内存泄露，严重情况下会是浏览器挂死</p>\n"
    }, {
        "id": 17,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">关于服务端传输数据</h1>\n<p>你就把服务器看成一间餐馆，apache是店面的传菜员，php是厨房的厨师。\n有些饮料之类的（静态资源，如：HTML、CSS、JS、Images等），不用经过厨师，直接由传菜员传递给顾客（Client）。\n如果需要厨师烹饪的菜式（例如：*.PHP等），就需要先等厨师把原始食材（php）烹饪完变成可以吃用的饭菜（静态资源），传菜员才能上菜。</p>\n<blockquote>\n<p>作者：人干士大夫......</p>\n</blockquote>\n<a href=/?17 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">关于服务端传输数据</h1>\n<p>你就把服务器看成一间餐馆，apache是店面的传菜员，php是厨房的厨师。\n有些饮料之类的（静态资源，如：HTML、CSS、JS、Images等），不用经过厨师，直接由传菜员传递给顾客（Client）。\n如果需要厨师烹饪的菜式（例如：*.PHP等），就需要先等厨师把原始食材（php）烹饪完变成可以吃用的饭菜（静态资源），传菜员才能上菜。</p>\n<blockquote>\n<p>作者：人干士大夫<br>链接：<a href=\"https://www.zhihu.com/question/19896544/answer/83808274\">https://www.zhihu.com/question/19896544/answer/83808274</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>\n</blockquote>\n"
    }, {
        "id": 18,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">前端模块化</h1>\n<h4 id=\"-\">历程:</h4>\n<ol>\n<li>函数封装: 一个文件编写几个相关函数<ul>\n<li>污染了全局变量,无法规避命名冲突</li>\n<li>模块成员之间没什么联系?</li>\n</ul>\n</li>\n<li>对象: 把所有模块成员封装在一个对象中,通过对象名来调用<ul>\n<li>外部可以随意修改内部成员</li>\n<li><strong>匿名函数自执行: 隐藏内部成员,外部无法修改</strong></li>\n<li><strong>这就是模块化的基础</strong></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"-\">规范......</h4>\n<a href=/?18 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">前端模块化</h1>\n<h4 id=\"-\">历程:</h4>\n<ol>\n<li>函数封装: 一个文件编写几个相关函数<ul>\n<li>污染了全局变量,无法规避命名冲突</li>\n<li>模块成员之间没什么联系?</li>\n</ul>\n</li>\n<li>对象: 把所有模块成员封装在一个对象中,通过对象名来调用<ul>\n<li>外部可以随意修改内部成员</li>\n<li><strong>匿名函数自执行: 隐藏内部成员,外部无法修改</strong></li>\n<li><strong>这就是模块化的基础</strong></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"-\">规范</h4>\n<p>目前通行的模块规范有两种:<strong>CommonJS</strong> 和 <strong>AMD</strong></p>\n<h6 id=\"commanjs\">CommanJS</h6>\n<ol>\n<li>根据CommonJS规范,一个单独的文件就是一个模块,每个模块都是单独的作用域,所以模块内部的变量,其他模块读取不到(除非定义为global对象的属性)</li>\n<li>模块输出: 只有一个出口module.exports对象,把需要模块输出的内容放入该对象</li>\n<li>加载使用模块: require方法,该方法读取一个文件并执行,返回文件内部的module.exports对象</li>\n</ol>\n<p>但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p>\n<h6 id=\"amd\">AMD</h6>\n<p>异步模块定义,是一个浏览器端模块化开发的规范  </p>\n<p>由于不是js原生支持,所以要用到库---requireJS</p>\n<p><strong>requireJS主要解决两个问题</strong></p>\n<ol>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ol>\n<p><strong>语法</strong></p>\n<p>requireJS定义了一个函数 define，它是全局变量，用来定义模块\n<code>define(id?, dependencies?, factory);</code></p>\n<ol>\n<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>\n<li>dependencies：是一个当前模块依赖的模块名称数组</li>\n<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>\n</ol>\n<p>在页面上使用require函数加载模块</p>\n<p><code>require([dependencies], function(){});</code></p>\n<p>require()函数接受两个参数</p>\n<ol>\n<li>第一个参数是一个数组，表示所依赖的模块</li>\n<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</li>\n</ol>\n<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>\n<h6 id=\"cmd\">CMD</h6>\n<p>通用模块定义\n依靠seaJS,解决的问题同上</p>\n<p><strong>语法:</strong></p>\n<p>define</p>\n<p><code>define(id?, deps?, factory)</code></p>\n<ol>\n<li>因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id</li>\n<li><p>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</p>\n<p> factory有三个参数</p>\n<p> <code>function(require, exports, module)</code></p>\n<ol>\n<li><p>require</p>\n<p> require 是 factory 函数的第一个参数</p>\n<p> <code>require(id)</code>\n require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口</p>\n</li>\n<li><p>exports</p>\n<p> exports 是一个对象，用来向外提供模块接口</p>\n</li>\n<li><p>module</p>\n<p> module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>加载模块</p>\n<p><code>seajs.use([&#39;myModule.js&#39;], function(my){});</code></p>\n<p><strong>AMD和CMD区别: </strong></p>\n<ul>\n<li><p>AMD: 依赖前置(在定义模块的时候就要声明其依赖的模块),</p>\n<ul>\n<li>在加载模块完成后就会执行该模块,所有模块加载+执行完后会进入require的回调函数,执行主逻辑,</li>\n<li>执行顺序与书写顺序不一定一致</li>\n</ul>\n</li>\n<li><p>CMD: 就近依赖(只有在用到某个模块的时候再去require),</p>\n<ul>\n<li>在加载完某个依赖模块后并不执行,值是下载,所有模块加载完以后进入主逻辑,遇到require才执行对应的模块,</li>\n<li><p>执行顺序和书写顺序是一致的</p>\n<p>AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>\n</li>\n</ul>\n</li>\n</ul>\n"
    }, {
        "id": 19,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-mac-apache-\">在Mac上搭建本地Apache服务器一些注意点</h1>\n<p>一般在开发ios程序中，我们需要使用到和服务器的交互操作。</p>\n<p>一般我们在Mac上使用Apache来搭建服务器。数据库采用MySQL。在Mac中Apache是自带的。所有，我们可以不需要额外的去Apple store下载。</p>\n<p>我们可以直接通过命令行的形式来，开启服务器。</p>\n<p>在终端中开启Apache的指令是：</p>\n<p>sudo apa......</p>\n<a href=/?19 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-mac-apache-\">在Mac上搭建本地Apache服务器一些注意点</h1>\n<p>一般在开发ios程序中，我们需要使用到和服务器的交互操作。</p>\n<p>一般我们在Mac上使用Apache来搭建服务器。数据库采用MySQL。在Mac中Apache是自带的。所有，我们可以不需要额外的去Apple store下载。</p>\n<p>我们可以直接通过命令行的形式来，开启服务器。</p>\n<p>在终端中开启Apache的指令是：</p>\n<p>sudo apachectl -k start   //这里要特别说明是，必须以root的身份来启动服务器（下同）\n//重启Apache指令\nsudo apachectl -k restatr\n开启后，在Safari中输入localhost。HTML页面显示为“it  work”，表明此时Apache 服务器已经开启了。\n其中默认的文件首页在&quot;/Library/WebServer/Documents/index.html&quot;中，\n如果我们要自定义站点的路径可以如下操作\n1.打开终端<br>   输入  cd  /etc/apache2    进入到配置apache目录\n   输入  sudo vim httpd.conf  //Apache配置文件,打开vim编辑器<br>   在vim编辑器中\n   输入 查找命令\n          /DocumentRoot   //找到默认文件路径  DocumentRoot &quot;/Library/WebServer/Documents&quot;该目录普通用户没有写入权限，需要输入管理员密码\n   在这里我们利用点击键盘i键，从命令模式进去到vim的编辑模式， 我们可以改成 DocumentRoot &quot;/Users/aple/Sites&quot; //其中aple代表用户名，Sites表示站点文件夹。\n    再次输入查找命令\n         /DocumentRoot  //找到<Directory \"/Library/WebServer/Documents\">,改成自定义路径。如下图所示。</p>\n<p>  如果需要浏览该文件夹下的内容，可以在</Directory>前添加：</p>\n<pre><code>Options Indexes\n\n\n  这样配置就完成了。\n</code></pre><p>在默认情况下。服务器对PHP支持是关闭的，如果要打开对PHP的支持，应该进行如下操作\n打开终端输入\ncd /etc/apache2\nsudo vim httpd.conf\n/php\n按字母x，删除#，然后按ESC，输入:wq退出编辑器\ncd /etc/\nsudo cp php.ini.default php.ini    //复制命令将php.ini.default复制为php.ini。\n重新启动Apache服务器\n这样就打开了支持PHP的功能。\n另外补充一点。可能用到的vim命令\nvim中有两种模式</p>\n<p>命令模式，用于输入命令(注意输入法要在英文状态)</p>\n<p>(1)shift+V  可以选中一行\n(2)y  复制一行\n(3)p  在当前行下方粘贴复制的内容\n(4)d$  删除到行尾\n(5)x  删除一个字符\n(6):wq  保存退出\n(7):q!  不保存退出\n(8):set nu  显示行号\n(9) i 进入编辑模式\n 编辑模式：用于编辑按ESC可以切换回命令模式</p>\n<p>重启服务器时会出现：httpd: Could not reliably determine the server&#39;s fully qualified\n那是因为没有配置localhost端口为80\n进入vim，加入  ServerName localhost:80即可解决</p>\n"
    }, {
        "id": 20,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">基础词汇</h1>\n<ul>\n<li>CDN:<br>  全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向......</li>\n</ul>\n<a href=/?20 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">基础词汇</h1>\n<ul>\n<li><p>CDN:<br>  全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>\n</li>\n<li><p>Grunt<br>  自动化构建工具--对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。</p>\n</li>\n<li><p>NPM<br>  全称是Node Package Manager[1]  ，是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。有了NPM，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包。</p>\n</li>\n<li><p>zepto<br>  类似于jQuery的类库,但大小不到jQuery的三分之一\n  最初目标在移动端提供一个精简的类似jquery的js库。</p>\n</li>\n<li><p>Node.js<br>是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>\n</li>\n<li><p>命名空间\n常用于xml中,由于标签名是开发者定义的,所以命名容易发生重复,导致问题  </p>\n<ol>\n<li><p>所以引入前缀的解决办法(创建了两种不同类型的table元素): </p>\n<pre><code class=\"lang-xml\"> 此文档带有某个表格中的信息：\n &lt;h:table&gt;\n &lt;h:tr&gt;\n &lt;h:td&gt;Apples&lt;/h:td&gt;\n &lt;h:td&gt;Bananas&lt;/h:td&gt;\n &lt;/h:tr&gt;\n &lt;/h:table&gt;\n 此 XML 文档携带着有关一件家具的信息：\n &lt;f:table&gt;\n &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;\n &lt;f:width&gt;80&lt;/f:width&gt;\n &lt;f:length&gt;120&lt;/f:length&gt;\n &lt;/f:table&gt;\n</code></pre>\n</li>\n<li><p>使用命名空间,为table标签添加一个xmlns属性,这样就为前缀赋予了一个与某个命名空间相关联的限定名称</p>\n<pre><code class=\"lang-xml\"> 这个 XML 文档携带着某个表格中的信息：\n &lt;h:table xmlns:h=&quot;namespaceURI&quot;&gt;\n &lt;h:tr&gt;\n &lt;h:td&gt;Apples&lt;/h:td&gt;\n &lt;h:td&gt;Bananas&lt;/h:td&gt;\n &lt;/h:tr&gt;\n &lt;/h:table&gt;\n 此 XML 文档携带着有关一件家具的信息：\n &lt;f:table xmlns:f=&quot;namespaceURI&quot;&gt;\n &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;\n &lt;f:width&gt;80&lt;/f:width&gt;\n &lt;f:length&gt;120&lt;/f:length&gt;\n &lt;/f:table&gt;\n</code></pre>\n</li>\n<li><p>关于xmlns(XML Namespace)属性</p>\n<ul>\n<li>语法: xmlns: 命名空间前缀=&quot;命名空间url&quot;</li>\n<li><p>默认的命名空间（Default Namespaces）\n  为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。\n  请使用下面的语法：\n  xmlns=&quot;namespaceURI&quot;</p>\n<pre><code class=\"lang-xml\">  这个 XML 文档携带着某个表格中的信息：\n  &lt;table xmlns=&quot;namespaceURI&quot;&gt;\n  &lt;tr&gt;\n  &lt;td&gt;Apples&lt;/td&gt;\n  &lt;td&gt;Bananas&lt;/td&gt;\n  &lt;/tr&gt;\n  &lt;/table&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n"
    }, {
        "id": 21,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-form-dom-\">对于form表单的DOM操作</h1>\n<ol>\n<li><code>var form = document.getElementsByTagName(&quot;form&quot;)[0]</code>获取到form对象</li>\n<li><code>form.passw</code>可以直接用formNode.name值 获取到对应的该form下的input/select/textarea元素</li>\n<li><code>form.username.value</code>可以根据name值直接获取到该for......</li>\n</ol>\n<a href=/?21 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-form-dom-\">对于form表单的DOM操作</h1>\n<ol>\n<li><code>var form = document.getElementsByTagName(&quot;form&quot;)[0]</code>获取到form对象</li>\n<li><code>form.passw</code>可以直接用formNode.name值 获取到对应的该form下的input/select/textarea元素</li>\n<li><code>form.username.value</code>可以根据name值直接获取到该form单元的任何子input/select/textarea元素的value值</li>\n</ol>\n<h4 id=\"-\">表单控件的事件:</h4>\n<ul>\n<li>form1.userName.onchange//当表单控件的值发生改变的时候触发</li>\n<li>form1.userName.oninput//当输入 表单控件 进行修改内部内容的时候触发，只要输入就会触发</li>\n<li>form1.onsubmit//当表单提交的时候触发</li>\n<li>form1.onreset//当表单重置的时候触发</li>\n</ul>\n<h4 id=\"-\">表单方法</h4>\n<ul>\n<li>form1.submit();<br>  提交表单到表单对应的action地址</li>\n<li>form1.reset();<br>  重置表单到默认状态</li>\n</ul>\n"
    }, {
        "id": 22,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-table-dom-\">对于table元素的DOM操作</h1>\n<ol>\n<li>table.tHead---获取表格头部(单数，获取到的是一个元素)</li>\n<li>table.tFoot---获取表格底部(单数，获取到的是一个元素)</li>\n<li>table.tBodies---获取表格主体(复数,获取到的是一个集合)</li>\n<li>tBodies[n].rows/tHead.rows/tFoot.rows(复数,获取到的是一个集合,就是表格的......</li>\n</ol>\n<a href=/?22 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-table-dom-\">对于table元素的DOM操作</h1>\n<ol>\n<li>table.tHead---获取表格头部(单数，获取到的是一个元素)</li>\n<li>table.tFoot---获取表格底部(单数，获取到的是一个元素)</li>\n<li>table.tBodies---获取表格主体(复数,获取到的是一个集合)</li>\n<li>tBodies[n].rows/tHead.rows/tFoot.rows(复数,获取到的是一个集合,就是表格的行tr)</li>\n<li>rows[n].cells(复数,获取到的是一个集合,就是表格的td)</li>\n</ol>\n"
    }, {
        "id": 23,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">模板引擎:</h1>\n<p>学习的是<a href=\"https://github.com/aui/artTemplate\">artTemplate模板引擎</a>点击进入github地址  </p>\n<p>它的语法分两种</p>\n<ol>\n<li><p>简洁语法</p>\n<p> 推荐使用，语法简单实用，利于读写。</p>\n<p> ```javascript\n{{if admin}}\n {{include &#39;admin_content&#39;}}</p>\n<p> {{e......</p>\n</li>\n</ol>\n<a href=/?23 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">模板引擎:</h1>\n<p>学习的是<a href=\"https://github.com/aui/artTemplate\">artTemplate模板引擎</a>点击进入github地址  </p>\n<p>它的语法分两种</p>\n<ol>\n<li><p>简洁语法</p>\n<p> 推荐使用，语法简单实用，利于读写。</p>\n<pre><code class=\"lang-javascript\">{{if admin}}\n {{include &#39;admin_content&#39;}}\n\n {{each list}}\n     &lt;div&gt;{{$index}}. {{$value.user}}&lt;/div&gt;\n {{/each}}\n{{/if}}\n</code></pre>\n</li>\n<li><p>原生语法</p>\n<pre><code class=\"lang-javascript\">&lt;%if (admin){%&gt;\n &lt;%include(&#39;admin_content&#39;)%&gt;\n\n &lt;%for (var i=0;i&lt;list.length;i++) {%&gt;\n     &lt;div&gt;&lt;%=i%&gt;. &lt;%=list[i].user%&gt;&lt;/div&gt;\n &lt;%}%&gt;\n&lt;%}%&gt;\n</code></pre>\n</li>\n</ol>\n<p>而用法也有两种</p>\n<ol>\n<li>script标签模板<br> 步骤如下:<ol>\n<li><head>标签引入<code>template-native.js</code>文件</li>\n<li><body>标签里写上script标签(注意type=&quot;text/html&quot;)并给其加上id,标签里写入模板</li>\n<li>开始使用<ol>\n<li>var data = {} //把要渲染的数据准备好</li>\n<li>var html = template(&#39;模板script的id&#39;, 数据对象名data)</li>\n<li>赋值给标签innerHTML</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>字符串模板<br> 步骤如下:<ol>\n<li><head>标签引入<code>template-native.js</code>文件</li>\n<li>var data = {} //把要渲染的数据准备好    </li>\n<li>var str = 模板引擎(字符串)</li>\n<li>var fn = template.render(str); //得到渲染函数</li>\n<li>把<code>fn(data)</code>赋值给标签<code>innerHTML</code></li>\n</ol>\n</li>\n</ol>\n"
    }, {
        "id": 24,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">自定义滚动条</h1>\n<p>基本结构就是包一层</p>\n<pre><code class=\"lang-html\">&lt;!--可视区--&gt;\n&lt;div id=&quot;box&quot;&gt;\n    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!--滚动条区--&gt;\n&lt;div id=&quot;bar&quot;&gt;\n    &lt;div id=&quot;bar-div&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>样式:</p>\n<p>```css</p>\n<p>#bar{\n    width: 10p......</p>\n<a href=/?24 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">自定义滚动条</h1>\n<p>基本结构就是包一层</p>\n<pre><code class=\"lang-html\">&lt;!--可视区--&gt;\n&lt;div id=&quot;box&quot;&gt;\n    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!--滚动条区--&gt;\n&lt;div id=&quot;bar&quot;&gt;\n    &lt;div id=&quot;bar-div&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>样式:</p>\n<pre><code class=\"lang-css\">#bar{\n    width: 10px;\n    height: 300px;\n    border: 1px solid gainsboro;\n    border-radius: 5px;\n    position: relative;\n    float: left;\n    margin-right: 10px;\n}\n#bar-div{\n    width: 10px;\n    height: 15px;\n    border-radius: 5px;\n    background: gray;\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n#box{\n    width: 302px;\n    height: 302px;\n    background: white;\n    border: 1px solid gainsboro;\n    float: left;\n    position: relative;\n    border-radius: 5px;\n    overflow: hidden;\n}\n#inner{\n    padding: 5px;\n    position: absolute;\n    left: 0;\n    top: 0;\n}\n</code></pre>\n<p>js交互部分:\n思路:</p>\n<ol>\n<li>通过窗口占内容的比例,计算出滚动条的高度</li>\n<li>计算内容最大滚动距离 以及 滑块最大滚动距离(这些是之后计算某时刻相对应的滚动距离的参照)</li>\n<li>添加事件:<ol>\n<li>在滑块上按下时,记录按下位置相对于滑块顶部的距离</li>\n<li>鼠标移动时,动态计算出滑块应该在的位置(同时要限制一下最高和最低位置,以免滑块滑出滑槽)</li>\n<li>同时根据比例动态算出内容块应该滚动到的位置</li>\n<li>鼠标抬起,将鼠标移动函数去掉</li>\n<li>记住清除浏览器默认行为</li>\n</ol>\n</li>\n<li><p>添加鼠标滚动事件</p>\n<p> ```javascript\n function goUp(){</p>\n<pre><code> y-=5;        \n y = y&lt;0? 0 : y;\n\n barDiv.style.top = y + &quot;px&quot;;\n\n var rate = y/maxTop;\n\n inner.style.top = -innerMaxTop*rate+&quot;px&quot;\n</code></pre><p> }<br> function goDown(){</p>\n<pre><code> y+=5;\n y = y&gt;maxTop? maxTop:y;\n\n barDiv.style.top = y + &quot;px&quot;;\n\n var rate = y/maxTop;\n\n inner.style.top = -innerMaxTop*rate+&quot;px&quot;\n</code></pre><p> }</p>\n</li>\n</ol>\n<pre><code>function addScroll(obj,fnUp,fnDown) {//为obj添加鼠标滚轮事件处理函数\n    obj.onmousewheel = fn; //通过on绑定鼠标滚轮事件\n    obj.addEventListener(&quot;DOMMouseScroll&quot;,fn); //通过事件侦听绑定鼠标滚轮事件\n\n    function fn (e) {\n        if(e.wheelDelta) {//该变量只有chrome有\n            e.wheelDelta&lt;0? fnDown():fnUp();\n            return false;\n        }\n        if(e.detail) {//该变量只有firefox有\n            e.detail&gt;0?fnDown():fnUp();\n            e.preventDefault();\n        }\n    }\n}\n\naddScroll(bar,goUp,goDown)\naddScroll(inner,goUp,goDown)\n\n```\n</code></pre>"
    }, {
        "id": 25,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h2 id=\"-keycode\">键盘事件常用的Keycode</h2>\n<p><em>keycode: 按下的键对应的Unicode值</em></p>\n<ol>\n<li>回车: 13</li>\n<li>空格: 32</li>\n<li>左: 37</li>\n<li>上: 38</li>\n<li>右: 39</li>\n<li>下: 40</li>\n<li>shift: 16</li>\n<li>ctrl: 17</li>\n</ol>\n<p>还有ctrlKey/shiftkey/altKey,都是布尔值,检测组合键用......</p>\n<a href=/?25 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h2 id=\"-keycode\">键盘事件常用的Keycode</h2>\n<p><em>keycode: 按下的键对应的Unicode值</em></p>\n<ol>\n<li>回车: 13</li>\n<li>空格: 32</li>\n<li>左: 37</li>\n<li>上: 38</li>\n<li>右: 39</li>\n<li>下: 40</li>\n<li>shift: 16</li>\n<li>ctrl: 17</li>\n</ol>\n<p>还有ctrlKey/shiftkey/altKey,都是布尔值,检测组合键用</p>\n"
    }, {
        "id": 26,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-for-\">闭包在for循环中的应用</h1>\n<p>```javascript\nvar divs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; divs.length; i++) {\n    tab(i);\n}\nfunction tab(n){\n    divs[n].onclick = function(){\n        alert(n);......</p>\n<a href=/?26 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-for-\">闭包在for循环中的应用</h1>\n<pre><code class=\"lang-javascript\">var divs = document.getElementsByTagName(&quot;div&quot;);\nfor (var i = 0; i &lt; divs.length; i++) {\n    tab(i);\n}\nfunction tab(n){\n    divs[n].onclick = function(){\n        alert(n);\n    }\n}\n</code></pre>\n<hr>\n<p>注意</p>\n<p>1 闭包允许内层函数引用父函数中的变量，但是该变量是最终值</p>\n<pre><code class=\"lang-javascript\">/**  \n * &lt;body&gt;  \n * &lt;ul&gt;  \n *     &lt;li&gt;one&lt;/li&gt;  \n *     &lt;li&gt;two&lt;/li&gt;  \n *     &lt;li&gt;three&lt;/li&gt;  \n *     &lt;li&gt;one&lt;/li&gt;  \n * &lt;/ul&gt;  \n */\n\nvar lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    lists[ i ].onmouseover = function(){  \n        alert(i);      \n    };  \n}\n</code></pre>\n<p>你会发现当鼠标移过每一个\\<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？  </p>\n<ol>\n<li>当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；  </li>\n<li>因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；  </li>\n<li>所以，最终每次弹出的都是4。  </li>\n</ol>\n<p><strong>解决方法一：</strong></p>\n<pre><code class=\"lang-javascript\">var lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    (function(index){  \n        lists[ index ].onmouseover = function(){  \n            alert(index);      \n        };\n    })(i);  \n}\n</code></pre>\n<p><strong>解决方法二：</strong></p>\n<pre><code class=\"lang-javascript\">function eventListener(list, index){  //相比于最开始的那种方法,这个函数更纯,不依赖外部变量\n    list.onmouseover = function(){  \n        alert(index);  \n    };  \n}  \nvar lists = document.getElementsByTagName(&#39;li&#39;);  \nfor(var i = 0 , len = lists.length ; i &lt; len ; i++){  \n    eventListener(lists[ i ] , i);  \n}\n</code></pre>\n<hr>\n<p>2 内存泄露<br>使用闭包十分容易造成浏览器的内存泄露(内存占用过量)，严重情况下会是浏览器挂死</p>\n"
    }, {
        "id": 27,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">面试准备</h1>\n<ol>\n<li>自我介绍</li>\n<li>算法与数据结构</li>\n<li>排序</li>\n<li>项目介绍</li>\n<li>es6新增</li>\n<li>弹性盒模型</li>\n<li>正则表达式</li>\n<li>事件那一块</li>\n<li>了解公司</li>\n<li>字符串方法,数组方法</li>\n<li>有什么问题</li>\n</ol>\n<hr>\n<ol>\n<li><p>列举web性能优化？</p>\n<p> 1) 减少http请求次数。合并文件、利用css sprite把零散的图片整合到一张图上。......</p>\n</li>\n</ol>\n<a href=/?27 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">面试准备</h1>\n<ol>\n<li>自我介绍</li>\n<li>算法与数据结构</li>\n<li>排序</li>\n<li>项目介绍</li>\n<li>es6新增</li>\n<li>弹性盒模型</li>\n<li>正则表达式</li>\n<li>事件那一块</li>\n<li>了解公司</li>\n<li>字符串方法,数组方法</li>\n<li>有什么问题</li>\n</ol>\n<hr>\n<ol>\n<li><p>列举web性能优化？</p>\n<p> 1) 减少http请求次数。合并文件、利用css sprite把零散的图片整合到一张图上。</p>\n<p> 2) 减少DNS查找。</p>\n<p> 3) 减少从定向。</p>\n<p> 4) 响应时间。使用AJAX进行缓存，减少http请求。</p>\n<p> 5) 延迟载入组件.</p>\n<p> 6) 预载入组件。</p>\n<p> 7) 减少节点的数量。</p>\n<p> 8) 切分组件到多个域。</p>\n<p> 9) 最小化iframe。</p>\n<p> 10) 杜绝http404错误。</p>\n</li>\n<li><p>介绍一下XMLHttpRequest对象的常用方式和属性?</p>\n<p> open(“method”,”URL”,还否异步) 建立对服务器的调用，</p>\n<pre><code> 第一个参数是HTTP请求方式,可以为GET，POST或任何服务器所支持的您想调用的方式。\n 第二个参数是请求页面的URL。\n</code></pre><p> send()方法，发送具体请求</p>\n<p> abort()方法，停止当前请求</p>\n</li>\n</ol>\n<pre><code>readyState属性 请求的状态 有5个可取值 0=未初始化 ，1=正在加载\n</code></pre><p>2=以加载，3=交互中，4=完成</p>\n<p>responseText 属性 服务器的响应，表示为一个串</p>\n<p>reponseXML 属性 服务器的响应，表示为XML</p>\n<p>status 服务器的HTTP状态码，200对应ok 400对应not found</p>\n<p>3、 URl地址获取对应参数的值，请写出最优的代码。Var URL=‘http：// www.ehecd.com/query?</p>\n<p>4、 请使用原生JavaScript给下面列表中的节点绑定点对象，兼容IE和标准浏览器？</p>\n<body>\n    <p>使用原生JavaScript给下面列表中的结点绑定点击事件，点击时创建一个Object对象，兼容IE和标准浏览器</p>\n    <ul id = \"nav\">\n    <li><a href=\"【聚划算】无所不能聚\">品牌团</a></li>\n\n15 <li><a href=\"【聚划算】整点聚_抢运气享乐趣\">整点聚</a></li>\n\n16 <li><a href=\"【聚划算】聚家装\">聚家装</a></li>\n\n17 <li><a href=\"【聚划算】量贩团\">量贩团</a></li>\n\n18 </ul>\n\n19 <script>\n\n20 var li_class = document.getElementById(&#39;nav&#39;).getElementsByTagName(&#39;li&#39;);\n\n21\n\n    for (var i = li_class.length - 1; i &gt;= 0; i--) {\n\n    (function(i){    li_class[i].addEventListener(&#39;click&#39;,function(e){\n     console.log({index:i,name:li_class[i].firstElementChild.innerHTML,link:li_class[i].firstElementChild.href});\n\n26 e.preventDefault();\n\n27 });\n\n28 })(i)\n\n29 };\n\n30\n\n31 </script>\n\n32 </body>\n\n<p>5、 请使用原生JavaScript给Array本地对象增加一个原型方法，用于删除数组中重复的数据，返回一个包含被删除的数据的新数组。</p>\n<p>Array.prototype.distinct=function(){</p>\n<p>var arr=[];\nvar obj={};\nfor(var i=0;i&lt;this.length;i++){\nif(obj[this[i]]==undefined)\nobj[this[i]]=this[i];\nelse if(obj[this[i]])\narr.push(this[i]);\n}\nreturn arr;\n}\nalert([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;a&#39;,&#39;e&#39;].distinct());</p>\n<p>6、 请说明setTimeout与setInterval的区别？</p>\n<p>setTimeout只加载一次，setInterval每隔指定的时间就执行一次表达式 \n所以,完全是不一样的 。</p>\n<p>7、 CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？内联和important哪个优先级高？</p>\n<p>css 有 3 种选择器: 派生选择器, 如, ul li {} id 选择器, 如, #id {}类选择器,。可以继承的有：font-size font-family color 。 优先级算法用CSS specificity，它是衡量一个衡量CSS值优先级的一个标准，</p>\n<p>!important 的优先级最高。</p>\n<p>8、 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?经常遇到的浏览器兼容性有哪些？怎么会出现？解决方法是什么？</p>\n<p>IE内核浏览器：360 ，傲游，搜狗，世界之窗，腾讯TT；</p>\n<p>非IE内核浏览器：firefox opera safari chrome</p>\n<ol>\n<li><p>就是ie6双倍边距的问题，，在使用float的情况下，不管是左还是右都会出现，最简单的解决方法就是用display:inline。</p>\n</li>\n<li><p>文字本身的大小不兼容。同样是font-size:14px的字体，在不同浏览器下占用的空间是不一样的，ie下世纪占高16px，下留白3px，ff下实际占高17px，上留白1px，下留白3px，opera下就更不一样了。解决方案：给文字设定 line-height 。确保所有文字都有默认的 line-height 值。这点很重要，在高度上我们不能容忍1px 的差异。</p>\n</li>\n<li><p>ff下容器高度限定，即容器定义了height之后，容器边框的外形就确定了，不会被内容撑大，而ie下是会被内容撑大，高度限定失效。所以不要轻易给容器定义height。</p>\n</li>\n<li><p>还讨论内容撑破容器问题，横向上的。如果float 容器未定义宽度，ff下内容会尽可能撑开容器宽度，ie下则会优先考虑内容折行。故，内容可能撑破的浮动容器需要定义width。</p>\n</li>\n<li><p>浮动的清除，ff下不清除浮动是不行的。</p>\n</li>\n<li><p>mirrormargin bug，当外层元素内有float元素时，外层元素如定义margin-top:14px，将自动生成margin-bottom:14px。padding也会出现类似问题，都是ie6下的特产，该类bug 出现的情况较为复杂，远不只这一种出现条件，还没系统整理。解决方案：外层元素设定border 或 设定float。</p>\n</li>\n<li><p>吞吃现象，限于篇幅，我就不展开了。还是ie6，上下两个div，上面的div设置背景，却发现下面没有设置背景的div 也有了背景，这就是吞吃现象。对应上面的背景吞吃现象，还有滚动下边框缺失的现象。解决方案：使用zoom:1。这个zoom好象是专门为解决ie6 bug而生的。</p>\n</li>\n<li><p>注释也能产生bug~~~“多出来的一只猪。”这是前人总结这个bug使用的文案，ie6的这个bug 下，大家会在页面看到猪字出现两遍，重复的内容量因注释的多少而变。解决方案：用“&lt;!–[if !IE]&gt; picRotate start &lt;![endif]–&gt;”方法写注释。</p>\n</li>\n<li><p><li/>里加 float <div/>，这是一个典型的，棘手的兼容问题，希望引起大家正视 ，给li 不同的属性会有不同的解释效果，ff下的解释稍可理解，ie6下的解释会让你摸不着头脑，由于问题的复杂性，将另起一文专门讨论该问题。在《ul使用心得》一文里有相关成果，却没给出问题解决的过程。</p>\n</li>\n<li><p>img下的留白。解决方案：给img设定 display:block。</p>\n</li>\n<li><p>失去line-height。<div style=”line-height:20px”><img />文字</div>，很遗憾，在ie6下单行文字 line-height 效果消失了。。。，原因是<img />这个inline-block元素和inline元素写在一起了。解决方案：让img 和文字都 float起来。</p>\n</li>\n</ol>\n<p>9、 请列举几种可以清除浮动的方法（至少两种）。</p>\n<p>采用伪类:after进行后续空制的高度位零的伪类层清除</p>\n<p>采用css overflow:auto的方式撑高</p>\n<p>采用css overflow:hidden的方式产生怪异适应</p>\n<p>采用display:table将对象变成table形式</p>\n<p>采用div标签，以及css的clear属性</p>\n<p>采用br标签，以及其自身html的clear属性</p>\n<p>10、 请缩写以下代码？</p>\n<p>.box{</p>\n<p>background-position: 10px 20px;</p>\n<p>background-repeat: no-repeat;</p>\n<p>background-attachment: fixed;</p>\n<p>background-color: red;</p>\n<p>background-image: url(&quot;box.png&quot;);</p>\n<p>}</p>\n<p>background: color url(&quot;&quot;) attachment repeat position;</p>\n<p>11、 display: none和visibility: hidden的区别是什么？</p>\n<p>两者都是把网页上的某个元素隐藏起来的，但是display: none是彻底删除删除这个对象，visibility: hidden只是把这个元素隐藏了，然而，元素所占的空间没有改变。</p>\n<p>12、 请使用html和css实现以下效果，尽量不要使用float。</p>\n<p>13、 最近关注了哪些前端相关技术/博客/论坛，简述心得和看法？</p>\n<p>-----伪类和伪元素的区别\n伪类的效果可以通过添加一个实际的class类来模拟,伪元素的效果则需要添加一个实际的元素才行</p>\n<hr>\n<p>做个读后感 ：）</p>\n<p>重绘：对某个区域、对象的重新渲染表现</p>\n<p>回流：对某个区域、对象进行重绘，根据条件影响到它的祖先对象进入重绘（并可能无限递归直到顶级祖先对象）</p>\n<p>重绘如何出现：改变对象的形状、坐标、表现以及内容都会引发该对象被重新渲染，这种现象即为重绘。</p>\n<p>回流如何出现：当该对象即将重绘时，浏览器会根据条件判断该对象的重绘结果是否会依赖该对象的祖先元素。如果有则将该对象祖先元素也加入本次重绘。并一直向上寻找，直到条件不匹配。此现象即为回流。</p>\n<p>最后总结：\n1、重绘可能引发回流\n2、回流必定引发重绘\n3、回流条件……暂时未知</p>\n"
    }, {
        "id": 28,
        "title": null,
        "time": "2017年2月1日",
        "description": "<h1 id=\"-\">元素尺寸</h1>\n<hr>\n<h3 id=\"-jquery-\"><em>jQuery下:</em></h3>\n<p><code>$().offset()</code><br>会返回一个对象,包含left和top的两个键值对,两个值是相对于<strong>可视窗口</strong>左侧和顶部的偏移距离<em>(新版jq有pageX和pageY)</em></p>\n<p><code>$().position()</code><br>会返回一个对象,包含left和top的两个键值对,两个值是相对于<strong>定位父级</strong>左侧和顶部的偏移距离......</p>\n<a href=/?28 style = \"color:red\">查看详情</a>",
        "tag": "test",
        "contentFile": "<h1 id=\"-\">元素尺寸</h1>\n<hr>\n<h3 id=\"-jquery-\"><em>jQuery下:</em></h3>\n<p><code>$().offset()</code><br>会返回一个对象,包含left和top的两个键值对,两个值是相对于<strong>可视窗口</strong>左侧和顶部的偏移距离<em>(新版jq有pageX和pageY)</em></p>\n<p><code>$().position()</code><br>会返回一个对象,包含left和top的两个键值对,两个值是相对于<strong>定位父级</strong>左侧和顶部的偏移距离</p>\n<h3 id=\"-\"><em>原生下</em></h3>\n<p>box.getBoundingClientRect()\n获取元素的盒模型信息,返回值为一个ClientRect对象(所有距离相对于浏览器可视区域）</p>\n<ul>\n<li>left right :元素左右与可视区域左边的距离,</li>\n<li>top bottom : 元素上下与可视区域左边的距离,</li>\n<li>width height：元素尺寸(包含padding和border)</li>\n</ul>\n<p>window.innerHeight(innerWidth): 浏览器窗口内部高度(宽度)\nwindow.outerHeight(outerWidth): 浏览器窗口整个高度(宽度)</p>\n<p>clientWidth/clientHeight 元素内部尺寸,(c + p)\nclientTop/clientLeft 元素上/左 边框的宽度</p>\n<p>offsetWidth/offsetHeight 元素整体尺寸,(c + p + b)</p>\n<p><strong>页面的滚动距离</strong></p>\n<blockquote>\n<p>BOM方法<br>window.pageXOffset / window.pageYOffset(页面的滚动距离)  </p>\n<p>DOM方法<br>document.body.scrollTop(chrome下) || document.documentElement.scrollTop(火狐下)(DOM方法获取页面滚动距离)</p>\n</blockquote>\n<hr>\n<p><strong>三高:</strong></p>\n<blockquote>\n<ul>\n<li>clientHeight:元素的height + padding</li>\n<li>offsetHeight:    元素的height + padding + border</li>\n<li>scrollHeight:    元素被子元素撑开的高度</li>\n</ul>\n</blockquote>\n<hr>\n<h5 id=\"-\">获取可视区的宽度、高度</h5>\n<blockquote>\n<p><strong>BOM 方法</strong><br><em>是w3c标准规定的，但是不兼容(移动端可以用BOM方法获取可视区宽度)</em><br><code>window.innerWidth</code><br><code>window.innerHeight</code><br><strong>DOM 方法</strong><br><em>不是w3c规定的，但是兼容(PC建议使用DOM方法获取)</em>\n<code>document.documentElement.clientWidth</code>\n<code>document.documentElement.clientHeight</code><br>注：document.documentElement &lt;==&gt; html</p>\n</blockquote>\n<hr>\n<h5 id=\"-\">获取元素宽高：</h5>\n<blockquote>\n<pre><code>**DOM 方法**  \n`node.clientWidth/clientHeight`        \n注：这个时候两个值是包括padding，但不包括border的\n</code></pre></blockquote>\n<hr>\n<p>window.scrollTo(X,Y)  </p>\n<ul>\n<li>设置页面滚动距离的</li>\n<li>页面对应滚动到X,Y的位置</li>\n</ul>\n<p>还有一个:计算后样式</p>\n<ul>\n<li>getComputedStyle(ele, attr)  </li>\n<li>getComputedStyle(ele)会返回一个对象,其中包含所有计算后样式</li>\n</ul>\n"
    }]
}
